# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/08_loggers.core.ipynb (unless otherwise specified).

__all__ = ['LoggerBase', 'LogCollector', 'is_pipe_instance', 'find_pipe_instance', 'Record', 'ProgressBarLogger',
           'RewardCollector']

# Cell
# Python native modules
import os,typing
# Third party libs
from fastcore.all import *
from torch.multiprocessing import Queue
import torchdata.datapipes as dp
from fastprogress.fastprogress import *
# Local modules
from ..pipes.core import *

# Cell
class LoggerBase(dp.iter.IterDataPipe):
    def __init__(self,source_datapipe=None):
        self.source_datapipe = source_datapipe
        self.main_queue = Queue()

    def connect_source_datapipe(self,pipe):
        self.source_datapipe = pipe
        return self


# Cell
class LogCollector(dp.iter.IterDataPipe):
    def __init__(self,source_datapipe,logger_bases:List[LoggerBase]):
        self.source_datapipe = source_datapipe
        self.main_queues = [o.main_queue for o in logger_bases]

    def __iter__(self): raise NotImplementedError

# Cell
def is_pipe_instance(pipe,cls): return isinstance(pipe,cls)
def find_pipe_instance(main_pipe,pipe_cls):
    return find_pipes(pipe,partial(is_pipe_instance,cls=pipe_cls))[0]

# Cell
class Record(typing.NamedTuple):
    name:str
    value:typing.Any

# Cell
class ProgressBarLogger(LoggerBase):
    def __init__(self,source_datapipe=None,epochs=None,show_on_pipe=None):
        self.source_datapipe = source_datapipe
        self.main_queue = Queue()
        self.epochs = epochs
        self.show_on_pipe = show_on_pipe

    def dequeue(self):
        while not self.main_queue.empty(): yield self.main_queue.get()

    def __iter__(self):
        epochs = find_pipe_instance(self,self.show_on_pipe).epochs if self.epochs is None else self.epochs
        mbar = master_bar(list(range(epochs)))

        attached_collectors = {o.name:o.value for o in self.dequeue()}

        mbar.write(attached_collectors, table=True)

        for step,epoch in zip(*(self.source_datapipe,mbar)):

            for o in self.dequeue(): attached_collectors[o.name] = o.value
            mbar.write([f'{l:.6f}' if isinstance(l, float) else str(l)
                        for l in attached_collectors.values()], table=True)
            yield step

# Cell
class RewardCollector(LogCollector):
    def __iter__(self):
        for q in self.main_queues: q.put(Record('reward',None))
        for step in self.source_datapipe:
            for q in self.main_queues: q.put(Record('reward',step.reward.detach().numpy()[0]))
            yield step