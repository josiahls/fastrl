# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_nbdev_extensions.ipynb.

# %% auto 0
__all__ = ['header', 'create_blog_notebook']

# %% ../nbs/00_nbdev_extensions.ipynb 1
# Python native modules
import os
from datetime import datetime
import os
import shutil
import json
# Third party libs
from fastcore.all import *
from nbdev.config import get_config
import yaml
from IPython.display import display, Markdown
from fastcore.all import call_parse
# Local modules

# %% ../nbs/00_nbdev_extensions.ipynb 5
def header(
    # The main header title to display.
    title: str,     
    # The subtitle to display underneath the title. If None, no subtitle will be displayed.                
    subtitle: Optional[str] = None, 
    # If True, the date associated with the header will be frozen, 
    # meaning it won't change in subsequent runs. 
    # If False, a new date will be generated each time the function is run,
    # and the date will not be saved to file.
    freeze: bool = False           
):
    """
    Function to generate a Markdown formatted header with an associated date.
    Dates are auto-incremented and can be frozen. This function also controls the persistent storage of dates.
    """
    filename = 'header_dates.json'
    date = None
    id:int = None

    # Load or initialize date dictionary
    if os.path.exists(filename):
        with open(filename, 'r') as file:
            dates = json.load(file)
    else:
        dates = {}

    # Determine the id for the new entry
    if freeze:
        # If frozen, use the maximum id from the file, or 0 if the file is empty
        id = max(dates.keys(), default=0)
    else:
        # If not frozen, increment the maximum id from the file, or use 0 if the file is empty
        id = max(dates.keys(), default=-1) + 1

    # Get or create the date
    date = dates.get(id)
    if date is None:
        date = datetime.now().strftime('%Y-%m-%d')
        dates[id] = date

        # Only write to file if the date is frozen
        if freeze:
            with open(filename, 'w') as file:
                json.dump(dates, file)

    # Display the markdown
    if subtitle is None:
        display(Markdown(f"# `{date}` **{title}**"))
    else:
        display(Markdown(f"# `{date}` **{title}**\n> {subtitle}"))


# %% ../nbs/00_nbdev_extensions.ipynb 8
@call_parse
def create_blog_notebook() -> None: # Creates a new blog notebook from template
    template = '99_blog.from_xxxx_xx_to_xx.ipynb'
    new_name = datetime.now().strftime('99_blog.from_%Y_%m_to_now.ipynb')

    # Check if the template file exists
    if not os.path.exists(template):
        raise FileNotFoundError(f"Template file '{template}' not found in current directory.")

    # Rename old notebooks and update sidebar.yml
    sidebar_file = '../sidebar.yml'
    with open(sidebar_file, 'r') as f:
        sidebar = yaml.safe_load(f)

    blog_section = None
    for section in sidebar['website']['sidebar']['contents']:
        print(section)
        if 'section' in section and section['section'] == 'Blog':
            blog_section = section['contents']
            break

    # Rename old notebooks
    for filename in os.listdir():
        if filename.startswith('99_blog.from_') and filename.endswith('_to_now.ipynb'):
            date_from = filename[13:20]  # corrected substring indexing
            date_to = datetime.now().strftime('%Y_%m')
            new_filename = f'99_blog.from_{date_from}_to_{date_to}.ipynb'
            os.rename(filename, new_filename)

            if blog_section is not None:
                # Update sidebar.yml
                old_entry = f'12_Blog/{filename}'
                new_entry = f'12_Blog/{new_filename}'
                if old_entry in blog_section:
                    blog_section.remove(old_entry)
                    blog_section.append(new_entry)

    # Add new notebook to sidebar.yml
    if f'12_Blog/{new_name}' not in blog_section:
        blog_section.append(f'12_Blog/{new_name}')
        
        with open(sidebar_file, 'w') as f:
            yaml.safe_dump(sidebar, f)

    # Create new notebook from template
    shutil.copy(template, new_name)
