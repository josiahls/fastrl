# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_fastai.loop.old.old.ipynb (unless otherwise specified).

__all__ = ['NodeException', 'Event', 'EVENT_ORDER_MAPPING', 'PREFIXES', 'event', 'NodeException', 'unwrap_nodes',
           'is_relevant_cb', 'Node', 'PREFIXES', 'intersection_idxs', 'CallbackException', 'Callback', 'Loop',
           'Learner', 'Outer', 'Inner', 'FailingInner', 'Node', 'PREFIXES', 'PRE2ORDER', 'Loop']

# Cell
# Python native modules
import os,sys
from copy import deepcopy,copy
from typing import *
import types
import logging
import inspect
# Third party libs
from fastcore.all import *
import numpy as np
# Local modules

_logger=logging.getLogger(__name__)

# Cell
EVENT_ORDER_MAPPING={}
PREFIXES=['before_','on_','after_','failed_','finally_']

class NodeException(Exception):pass

class Event(object):
    def __init__(self,
                 function:Callable,
                ):
        store_attr()

        full_name=function.__module__+'.'+function.__qualname__
        if full_name not in EVENT_ORDER_MAPPING: self.order=1
        else: self.order=EVENT_ORDER_MAPPING[full_name]
        EVENT_ORDER_MAPPING[full_name]=self.order+1

        if self.name.startswith('_') or not any(self.name.startswith(pre) for pre in PREFIXES):
            raise NodeException(f'{self.name} needs to start with any {PREFIXES}')

    def __call__(self,*args,**kwargs):

        return self.function(*args,**kwargs)

    @property
    def name(self): return self.function.__name__
    @property
    def prefix(self): return self.name.split('_')[0]
    @property
    def postfix(self): return '_'.join(self.name.split('_')[1:])

event=Event

# Cell
# Python native modules
import os,sys
from copy import deepcopy,copy
from typing import *
import types
import logging
import inspect
# Third party libs
from fastcore.all import *
import numpy as np
# Local modules

_logger=logging.getLogger(__name__)

# Cell
PREFIXES=['before_','on_','after_','failed_','finally_']

class NodeException(Exception):pass

def unwrap_nodes(n:'Node'):
    while n is not None:
        yield n
        n=n.parent

def is_relevant_cb(cb:'Callback',n:'Node'):
    return all([
        hasattr(cb,n.name),
        (cb.call_on is None or any([
            o in cb.call_on for o in unwrap_nodes(n)
        ]))
    ])

class Node(object):
    def __init__(self,
                 function:Callable,
                 parent:Optional['Node']=None,
                 children:Optional[List['Node']]=None,
                 loop:'Loop'=None):
        store_attr(but='cbs')
        self.order=None
        for anno in L(anno_ret(self.function)):
            if 'order' in anno.__args__:
                self.order=anno.__args__[-1]
        if self.order is None:
            raise NodeException(f'Node: {self.name} needs Literal["order",int]')
        self.cbs=[]
        if loop is not None:
            self.cbs=L(cb() for cb in L(loop.get_cbs()) if is_relevant_cb(cb,self))

    def run(self):
        ret,cb_rets=self.function(),None
        for cb in self.cbs:
            cb_ret=getattr(cb,self.name)(n=self)
            if cb_ret is not None:
                if cb_rets is None: cb_rets=cb_ret
                else:               cb_rets=merge(cb_rets,cb_ret)
        return merge(ret,ifnone(cb_rets,{})) if ret is not None else ret


    def __repr__(self):
        if self.cbs:
            strs=[cb.name(self.name,len(self.cbs)>i>0) for i,cb in enumerate(self.cbs)]
            return self.name+'\n'+self.loop.tab+'\n'.join(strs)+'\n'
        return self.name

    def __lt__(self,o:'Node'): return self.order<o.order
    def __eq__(self,o:Union['Node',Callable]):
        return getattr(o,'function',o).__qualname__==self.function.__qualname__

    @property
    def name(self): return self.function.__name__
    @property
    def prefix(self): return self.name.split('_')[0]
    @property
    def postfix(self): return '_'.join(self.name.split('_')[1:])
    @property
    def is_failure_node(self): return self.name.startswith('failed_')
    @property
    def is_finally_node(self): return self.name.startswith('finally_')

    @classmethod
    def isvalid(cls,name)->bool:
        if isinstance(name,Callable): name=name.__name__
        return not name.startswith('_') and \
          any(name.startswith(pre) for pre in PREFIXES)

# Cell
def intersection_idxs(a:L,b:L,after_insert=False):
    "Get the idx where elements in `a` appear in `b`. If `after_insert`=True, the offset the idxs."
    idxs=a.argwhere(lambda o:not isinstance(o,(list,L)) and o in b)
    if after_insert: return np.array(idxs)+np.arange(1,len(idxs)+1)
    else:            return np.array(idxs)

# Cell
class CallbackException(Exception):pass

class Callback(object):
    call_on,loop=None,None

    def __new__(cls,*args,**kwargs):
        for k,fn in inspect.getmembers(cls):
            if not Node.isvalid(k): continue

            if 'n' not in anno_dict(fn):
                msg=f'Function {k} of {cls} needs to have n:Node=None as an arg.'
                raise CallbackException(msg)

        return super(Callback, cls).__new__(cls, *args, **kwargs)

    def __repr__(self): return type(self).__name__

    def name(self,event:str=None,add_arrow=False):
        name=str(self)
        if event is not None:
            _event=getattr(self,event)
            annotations=deepcopy(anno_dict(_event))
            if 'return' in annotations:
                name+=f' -> {annotations["return"]}'
        if add_arrow: name=' '*(len(name)//2)+'\u2193'+'\n'+name
        return name

# Cell
def _groupby_prefix(n): return n.prefix
def _groupby_postfix(n): return n.postfix

class Loop(object):
    _common_obj,cbs,parent_loop=None,None,None

    def __init__(self,common_obj=None,cbs=None):
        self._common_obj=ifnone(common_obj,self._common_obj)
        self.cbs=ifnone(cbs,self.cbs)

    @classmethod
    def from_nodes(cls,loops,**kwargs):
        loop=cls(**kwargs)
        loop.nodes=loop.nodes(loops,instantiate=True,instance=loop)
        return loop

    def __call__(self): return self

    def get_cbs(self):
        for cb in L(self.cbs): cb.loop=self
        return L(self.cbs) if self.parent_loop is None else (self.parent_loop.get_cbs()+L(self.cbs))

    @property
    def common_obj(self):
        return ifnone(self._common_obj,ifnone(self.parent_loop,noop).common_obj)

    @classmethod
    def nodes(cls,loops,parent_node=None,instantiate=False,instance=None):
        loops=L(loops)
        loop=ifnone(instance,cls()) if instantiate else cls
        nodes=L(Node(n,loop=loop,parent=parent_node)
                for k,n in inspect.getmembers(loop) if Node.isvalid(k))
        nodes=nodes.sorted()
        for l in loops:
            for idx in intersection_idxs(nodes,l.call_on,after_insert=True):
                l.parent_loop=loop
                nodes.insert(idx,l.nodes(loops,parent_node=nodes[idx-1],
                                         instantiate=instantiate))
                nodes[idx-1].children=nodes[idx]
        return nodes

    def one_run(self,n:Node):
        cycle=True
        while cycle:
            cycle=False
            if isinstance(n,(L,list)):
                ret=n[0].loop.run(n)
            else:
                ret=n.run()
            if isinstance(ret,dict):
                cycle=ret.get('cycle',False)
                if self.common_obj is not None:
                    for k,v in self.ret.items(): setattr(self.common_obj,k,v)
        return ret

    def run(self,nodes=None):
        current_postfix,current_prefix,traceback=None,None,None
        for i,n in enumerate(ifnone(nodes,self.nodes)):
            if isinstance(n,Node):
                if n.postfix!=current_postfix and traceback: raise traceback
                current_postfix,current_prefix=n.postfix,(n.prefix+'_')
            if traceback and current_prefix in PREFIXES[:3]:  continue
            elif not traceback and current_prefix=='failed_': continue

            try:              ret=self.one_run(n)
            except Exception: traceback=sys.exc_info()[1]
            if ifnone(ret,{}).get('handled',False): traceback=None
        if traceback: raise traceback
        return ret

class Learner(object):pass
class Outer(Loop):
    common_obj=Learner

    def run(self,nodes=None):
        print('--- ENTERING OUTER LOOP ---')
        super().run(nodes)
        print('--- EXITING OUTER LOOP ---')

    def before_step(self) ->Literal['order',1]:  print('before_step')
    def on_step(self)     ->Literal['order',2]:  print('on_step')
    def after_step(self)  ->Literal['order',3]:  print('after_step')
    def failed_step(self) ->Literal['order',4]:  print('failed_step')
    def finally_step(self)->Literal['order',5]:  print('finally_step')

    def before_jump(self) ->Literal['order',6]:  print('before_jump')
    def on_jump(self)     ->Literal['order',7]:  print('on_jump')
    def after_jump(self)  ->Literal['order',8]:  print('after_jump')
    def failed_jump(self) ->Literal['order',9]:  print('failed_jump')
    def finally_jump(self)->Literal['order',10]: print('finally_jump')

class Inner(Loop):
    call_on=L(Outer.on_step,Outer.after_step,Outer.finally_jump)

    tab='\t'

    def run(self,nodes=None):
        print(self.tab,'--- ENTERING INNER LOOP ---')
        super().run(nodes)
        print(self.tab,'--- EXITING INNER LOOP ---')

    def before_iteration(self) ->Literal['order',1]: print(self.tab,'before_iteration')
    def on_iteration(self)     ->Literal['order',2]: print(self.tab,'on_iteration')
    def after_iteration(self)  ->Literal['order',3]: print(self.tab,'after_iteration')
    def failed_iteration(self) ->Literal['order',4]: print(self.tab,'failed_iteration')
    def finally_iteration(self)->Literal['order',5]: print(self.tab,'finally_iteration')

class FailingInner(Loop):
    call_on=L(Inner.finally_iteration)

    tab='\t\t'

    def run(self,nodes=None):
        print(self.tab,'--- ENTERING FailingInner LOOP ---')
        super().run(nodes)
        print(self.tab,'--- EXITING FailingInner LOOP ---')

    def on_force_fail(self) ->Literal['order',1]:
        print(self.tab,'on_force_fail')
        raise Exception

list(Outer.nodes([Inner,FailingInner],instantiate=True))

# Cell
# Python native modules
import os
from copy import deepcopy
from typing import *
import types
import logging
import inspect
# Third party libs
from fastcore.all import *
# Local modules

_logger=logging.getLogger(__name__)

# Cell
PREFIXES=['on_','after_','before_','failed_','finally_']
PRE2ORDER={'on_':2,'after_':3,'before_':1,'failed_':4,
           'finally_':5}

class Node(object):
    def __init__(self,
                 function:Callable, # The function to be called on this node.
                 base_loop=None,
                 # The BASE loop that this node is a part of. This will be
                 # different from the loop it is defined in.
                 loop=None, # The loop this node immediately reports to
                 children:List['Node']=None,
                 parent:'Node'=None,
                 order=0,
                 call_on='',
                 call_on2str:bool=False, # Whether to show the call_on the __repr__ and __str__ functions
                 order2str:bool=False, # Whether to show the order the __repr__ and __str__ functions
                 level2str:bool=False, # Whether to show the level the __repr__ and __str__ functions
                 indent2str:str='' # Amount and characters to indent the __repr__ and __str__ functions
                ):
        store_attr()
        if not self.isvalid(function):
            raise ValueError(f"""{function} cannot be private ('_'), and must have
                                 either {PREFIXES}""")
        self.sig=inspect.signature(function)
        self.name=function.__name__
        self.order=order
        self.user_defined_order=False
        for anno in L(anno_ret(function)):
            if 'order' in anno.__args__:
                self.order+=anno.__args__[-1]
                self.user_defined_order=True

        for pre in PREFIXES:
            if self.name.startswith(pre):
                self.postfix=self.name.replace(pre,'')
                self.prefix=pre
                # If order is 0, then we will define the order based on the prefix
                if self.order==0: self.order=PRE2ORDER[pre]
                break

    def __call__(self,*args,**kwargs): return self.function(*args,**kwargs)
    def __round__(self): return round(self.order)
    def __lt__(self,o:'Node'): return self.order<o.order

    @delegates(__init__,but='function,base_loop,loop,children,parent,order,call_on')
    def adjust_str(self,**kwargs):
        n=deepcopy(self)
        for k,v in kwargs.items(): setattr(n,k,v)
        return n

    def __str__(self):
        base=f"{self.function.__name__}"
        if self.call_on!='' and self.call_on2str: base=f"{self.call_on}:"+base
        if self.level2str:                        base=f"level:{self.level} "+base
        if self.order2str:                        base=f"order:{self.order} "+base
        base=self.indent2str*(self.level-1)+base
        return base

    def __repr__(self): return str(self)
    def __hash__(self): return hash(f'{self.call_on} {str(self)}')

    @property
    def level(self):
        return 1 if self.parent is None else (1+self.parent.level)

    @classmethod
    def isvalid(cls,name)->bool:
        if isinstance(name,Callable): name=name.__name__
        return not name.startswith('_') and \
          any(name.startswith(pre) for pre in PREFIXES)

add_docs(Node,"""Nodes are used to generate a static loop. They wrap whatever functions
are defined in that loop.""",
        adjust_str='If we want to change some of the str related params on the fly, we can call this method.')

# Cell
class Loop(object):
    core_obj=None
    call_on=''

    def __init__(self,
                 full_loop=None,
                 inner_loops=None
                ):
        store_attr()

    @classmethod
    def nodes(cls,
              loop_instance=None # If we want to actually run the nodes, we need to use a loop isntance
             )->List[Node]:
        nodes=L(Node(node) for k,node in inspect.getmembers(cls) if Node.isvalid(k))
        if loop_instance is not None:
            for n in nodes: n.function=getattr(loop_instance,n.name)
        # For a given set of nodes, fix the orders, and defining the order if it
        # it not defined for a given node.
        for postfix,subnodes in groupby(nodes,lambda o:o.postfix).items():
            # For a given subnode, we want to see if the user defined any of the orders
            if any(n.user_defined_order for n in subnodes):
                # If the user defined ONE of the orders then we need to make sure
                # the other nodes have orders that make sense.
                user_ordered_nodes=[n for n in subnodes if n.user_defined_order]
                if all([n.user_defined_order for n in subnodes]): pass
                elif len(user_ordered_nodes)==1:
                    max_order=max(user_ordered_nodes).order
                    idxs=L(subnodes).argwhere(lambda o:not o.user_defined_order)
                    for subn in L(subnodes)[idxs]:subn.order+=max_order
                elif len(user_ordered_nodes)>1:
                    # If the user defined MORE THAN ONE of the orders, then we will
                    # warn them and not mess with the orders.
                    _logger.warning("""nodes: %s have %s user defined orders.
                                       because there are more than 1 user defined
                                       orders, we will not be able to define them
                                       automatically.""",str(subnodes),len(user_ordered_nodes))
        # Duplicate the nodes if for a given node, it is called on 2 different
        # locations.
        final_nodes=L()
        if cls.call_on!='':
            for n in nodes:
                for call in L(cls.call_on.split(',')):
                    n.call_on=call
                    final_nodes.append(deepcopy(n))
        else:
            final_nodes=nodes
        return final_nodes.sorted()

    @classmethod
    def with_inner_loops(cls,
             loop_instance=None, # If we want to actually run the nodes, we need to use a loop isntance
             inner_loops:L=None # Either list of loop cls or instances
            ):
        if loop_instance is None:
            return cls.nodes()+L(inner_loops).map(Self.with_inner_loops()).concat()
        else:
            ns=cls.nodes(loop_instance=loop_instance)
            ns+=L(inner_loops).map(lambda o:o.with_inner_loops(loop_instance=o)).concat()
            return ns

    @classmethod
    def organized_nodes(cls,
             loop_instance=None, # If we want to actually run the nodes, we need to use a loop isntance
             inner_loops=None,
             as_dict=False)->Union[List[Node],Dict[str,Node]]:
        nodes=list(cls.with_inner_loops(loop_instance=loop_instance,inner_loops=inner_loops))
        # For the nodes that have `call_on`s it will be more efficient to map
        # them the function they are being called on. Nodes without call_ons we
        # can be confident are the root nodes.
        grouped_nodes=groupby(L(nodes),lambda o:o.call_on)
        grouped_nodes={g:L(l).sorted() for g,l in grouped_nodes.items()}
        # For each node, add the call_on nodes if they exist
        organized_nodes=L()
        order=0
        nodes=grouped_nodes['']
        while nodes:
            n=nodes.pop(0)
            # The order will cascade ensuring that all the nodes have their
            # respective orders organized. This is needed incase you execute `sorted`
            # on the final list of nodes.
            if order==0:
                order=n.order
            else:
                _order=order+n.order
                n.order+=order
                n.order=round(n.order,2)
                order=_order

            organized_nodes.append(n)
            if n.name in grouped_nodes:
                # If there are call_on nodes for `n`, then we want to process them
                # immediately after `n`. We reverse the list and add insert them
                # on index 0, thus the nodes that should go first will be in
                # index 0-ish and the ones that should go later will be farthur
                # down this list.
                n.children=grouped_nodes[n.name]
                for inner_n in reversed(grouped_nodes[n.name]):
                    inner_n.parent=n
                    nodes.insert(0,inner_n)
        return organized_nodes