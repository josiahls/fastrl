# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_fastai.loop.ipynb (unless otherwise specified).

__all__ = ['EventException', 'Event', 'EVENT_ORDER_MAPPING', 'PREFIXES', 'event', 'SectionException', 'Section',
           'isrelevent', 'class_or_instancemethod', 'Loop', 'Outer']

# Cell
# Python native modules
import os,sys
from copy import deepcopy,copy
from typing import *
import types
import logging
import inspect
from itertools import chain
from functools import partial
# Third party libs
from fastcore.all import *
import numpy as np
# Local modules

_logger=logging.getLogger(__name__)

# Cell
EVENT_ORDER_MAPPING={}
PREFIXES=['before_','on_','after_','failed_','finally_']

def _is_event(o): return issubclass(o.__class__,Event)
def _last_element(ls): return ls[-1]

class EventException(Exception):pass

class Event(object):
    def __init__(self,
                 function:Callable,
                 loop=None,
                ):
        store_attr()
        # We set the order over the entire Loop definition
        self.outer_name=function.__module__+'.'+function.__qualname__.split('.')[0]
        if self.outer_name not in EVENT_ORDER_MAPPING: self.order=1
        else: self.order=EVENT_ORDER_MAPPING[self.outer_name]
        EVENT_ORDER_MAPPING[self.outer_name]=self.order+1

        self.full_name=function.__module__+'.'+function.__qualname__

        if self.name.startswith('_') or not any(self.name.startswith(pre) for pre in PREFIXES):
            raise EventException(f'{self.name} needs to start with any {PREFIXES}')

    def __call__(self,*args,**kwargs):
        return self.function(self.loop,*args,**kwargs)
    def __lt__(self,o:'Event'): return self.order<o.order
    @property
    def name(self): return self.function.__name__
    @property
    def prefix(self): return self.name.split('_')[0]+'_'
    @property
    def postfix(self): return '_'.join(self.name.split('_')[1:])

    def __repr__(self):
        return self.full_name

event=Event

# Cell
def _grab_postfix(e:Union[Event,list],previous_event:dict=None):
    if not isinstance(e,Event):
        if not previous_event:
            raise SectionException(f'{e} doesnt have an event tied to it.')
        else:
            return previous_event['last_event']
    if previous_event is not None:
        previous_event['last_event']=e.postfix
    return e.postfix

def _grab_full_name(o:Event): return o.full_name
def _grab_prefix(o:Event): return o.prefix
def _default_raise(ex): raise

class SectionException(Exception):pass
def _event2dict(e:Union[Event,list,L],previous_event:dict):
    if not isinstance(e,Event):
        if not previous_event:
            raise SectionException(f'{e} doesnt have an event tied to it.')
        else:
            return (previous_event['last_event']+'inner',e)

    previous_event['last_event']=e.prefix
    return (e.prefix,e)

def _noop_event_pair(k):
    return ((k,noop if k!='failed_' else _default_raise),(k+'inner',[]))

class Section(object):

    def __init__(self,events):
        default_events=L(PREFIXES).map(_noop_event_pair)
        default_events=L(chain.from_iterable(default_events))
        previous_event={}
        self.events=merge(
            dict(default_events),
            dict(L(events).map(_event2dict,previous_event=previous_event))
        )

    def __repr__(self):
        s=str(self.__class__.__name__)+f' {len(self)} events'
        s+='\n'+'\n'.join([str(o) for o in self.events.values()])
        return s
    def __len__(self): return len(L(self.events.values()).filter(_is_event))

    def run(self):
        try:
            self.events['before_']()
            for o in self.events['before_inner']: o.run()
            self.events['on_']()
            for o in self.events['on_inner']: o.run()
            self.events['after_']()
            for o in self.events['after_inner']: o.run()
        except Exception as ex:
            try:     self.events['failed_']()
            finally:
                for o in self.events['failed_inner']: o.run()
        finally:
            self.events['finally_']()
            for o in self.events['finally_inner']: o.run()

    @classmethod
    def from_events(cls,events:List[Event]):
        previous_event={}
        event_groups=groupby(events,partial(_grab_postfix,previous_event=previous_event))
        return [cls(o) for o in event_groups.values()]

# Cell
def _is_event(o): return issubclass(o.__class__,Event)
def _last_element(ls): return ls[-1]
def _loop2sections(loop,loops,cbs): return loop.sections(loops=loops,cbs=cbs)
def isrelevent(loop,event:Event):
    if isinstance(event,(list,L)): return False
    return event.full_name in loop.call_on.map(_grab_full_name)

class class_or_instancemethod(classmethod):
    "From: https://stackoverflow.com/questions/28237955/same-name-for-classmethod-and-instancemethod"
    def __get__(self, instance, type_):
        descr_get = super().__get__ if instance is None else self.__func__.__get__
        return descr_get(instance, type_)

class Loop(object):
    call_on=L()

    @class_or_instancemethod
    def events(cls_or_self,loops=None,cbs=None):
        events=L(inspect.getmembers(cls_or_self)).map(_last_element)\
                                                 .filter(_is_event)\
                                                 .sorted()
        for o in events: o.loop=cls_or_self
        events=chain.from_iterable([
            (o,ifnone(loops,L()).filter(isrelevent,event=o)\
                                .map(_loop2sections,loops=loops,cbs=cbs))
            for o in events
        ])
        return events

    @class_or_instancemethod
    def sections(cls_or_self,loops=None,cbs=None):
        events=cls_or_self.events(loops=L(loops),cbs=L(cbs))
        sections=Section.from_events(events)
        return sections

    def run(self):
        sections=self.sections()
        for section in sections:
            section.run()

class Outer(Loop):
    @event
    def before_step(self) :  print('before_step')
    @event
    def on_step(self)     :  print('on_step')
    @event
    def after_step(self)  :  print('after_step')
    @event
    def failed_step(self) :  print('failed_step')
    @event
    def finally_step(self):  print('finally_step')

    @event
    def before_jump(self) :  print('before_jump')
    @event
    def on_jump(self)     :  print('on_jump')
    @event
    def after_jump(self)  :  print('after_jump')
    @event
    def failed_jump(self) :  print('failed_jump')
    @event
    def finally_jump(self):  print('finally_jump')

list(Outer.events())