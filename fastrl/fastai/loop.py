# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_fastai.loop.ipynb (unless otherwise specified).

__all__ = ['IN_IPYTHON', 'EventException', 'event_parent_iter', 'custom_traceback', 'Event', 'isrelevent',
           'EVENT_ORDER_MAPPING', 'PREFIXES', 'event', 'SectionException', 'Section', 'class_or_instancemethod', 'Loop',
           'CallbackException', 'Callback', 'ipy_handle_exception']

# Cell
# Python native modules
import os,sys
from copy import deepcopy,copy
from typing import *
import types
import logging
import inspect
from itertools import chain
from functools import partial
# Third party libs
from fastcore.all import *
import numpy as np
# Local modules

IN_IPYTHON=False

_logger=logging.getLogger(__name__)

# Cell
EVENT_ORDER_MAPPING={}
PREFIXES=['before_','on_','after_','failed_','finally_']

def _is_event(o): return issubclass(o.__class__,Event)
def _last_element(ls): return ls[-1]
def _grab_full_name(o:'Event'): return o.full_name

class EventException(Exception):pass

def event_parent_iter(event:'Event'):
    yield event
    while True:
        event=event.parent_event
        if event is None: break
        yield event

def custom_traceback():
    print('hi')

class Event(object):
    def __init__(self,
                 function:Callable,
                 loop=None,
                 parent_event=None
                ):
        store_attr()
        # We set the order over the entire Loop definition
        self.outer_name=function.__module__+'.'+function.__qualname__.split('.')[0]
        if self.outer_name not in EVENT_ORDER_MAPPING: self.order=1
        else: self.order=EVENT_ORDER_MAPPING[self.outer_name]
        EVENT_ORDER_MAPPING[self.outer_name]=self.order+1

        self.full_name=function.__module__+'.'+function.__qualname__

        if self.name.startswith('_') or not any(self.name.startswith(pre) for pre in PREFIXES):
            raise EventException(f'{self.name} needs to start with any {PREFIXES}')

        self.cbs=L()

    def set_cbs(self,cbs=None):
        if cbs is not None:
            self.cbs=L((cb() if isinstance(cb, type) else cb) for cb in L(cbs)
                       if hasattr(cb,self.name) and (not cb.call_on or any([isrelevent(cb,e) for e in event_parent_iter(self)])))

    @property
    def root_loop(self): return self.loop.root_loop
    def __call__(self,*args,**kwargs):
        ret=self.function(self.loop,*args,**kwargs)                             # fastrl.skip_traceback
        for cb in self.cbs: cb_ret=getattr(cb,self.name)()
        return ret

    def __lt__(self,o:'Event'): return self.order<o.order
    @property
    def name(self): return self.function.__name__
    @property
    def prefix(self): return self.name.split('_')[0]+'_'
    @property
    def postfix(self): return '_'.join(self.name.split('_')[1:])
    def __repr__(self): return self.full_name

    def show(self,n_tab=0,n_cbs=False,include_cbs=False,**kwargs):
        kwargs=merge(dict(n_cbs=n_cbs,include_cbs=include_cbs),kwargs)
        tab='\t' if self.loop is None or self.loop.root_loop is None else self.loop.root_loop.tab
        event=n_tab*tab+str(self.full_name)
        if self.cbs: event+=f' #{len(self.cbs)}'
        if include_cbs:
            for cb in self.cbs:
                event+='\n'+(n_tab*tab)+cb.show(n_tab=n_tab+1,**kwargs)
        return event

def isrelevent(loop_or_cb,event:Event):
    if isinstance(event,(list,L)): return False
    return event.full_name in loop_or_cb.call_on.map(_grab_full_name)

event=Event

# Cell
def _grab_postfix(e:Union[Event,list],previous_event:dict=None):
    if not isinstance(e,Event):
        if not previous_event:
            raise SectionException(f'{e} doesnt have an event tied to it.')
        else:
            return previous_event['last_event']
    if previous_event is not None:
        previous_event['last_event']=e.postfix
    return e.postfix

def _grab_prefix(o:Event): return o.prefix
def _default_raise(): raise
def _event2dict(e:Union[Event,list,L],previous_event:dict):
    if not isinstance(e,Event):
        if not previous_event:
            raise SectionException(f'{e} doesnt have an event tied to it.')
        else:
            return (previous_event['last_event']+'inner',e)

    previous_event['last_event']=e.prefix
    return (e.prefix,e)

def _noop_event_pair(k):
    return ((k,noop if k!='failed_' else _default_raise),(k+'inner',[]))


class SectionException(Exception):pass

class Section(object):

    def __init__(self,events,parent_event=None):
        store_attr(but='events')
        default_events=L(PREFIXES).map(_noop_event_pair)
        default_events=L(chain.from_iterable(default_events))
        previous_event={}
        self.events_ls=[o for o in events if not isinstance(o,(list,L)) or len(o)!=0]
        if parent_event is not None:
            for event in self.events_ls: event.parent_event=parent_event
        self.events=merge(
            dict(default_events),
            dict(L(self.events_ls).map(_event2dict,previous_event=previous_event))
        )

    @property
    def root_loop(self): return self.events_ls[0].root_loop
    @property
    def loop(self): return self.events_ls[0].loop
    def __repr__(self): return str(self.__class__.__name__)
    def __len__(self): return len(L(self.events.values()).filter(_is_event))

    @delegates(Event.show)
    def show(self,n_tab=0,n_events=False,include_events=False,include_defaults=False,**kwargs):
        kwargs=merge(dict(n_events=n_events,
                          include_events=include_events,
                          include_defaults=include_defaults),kwargs)
        tab='\t' if self.root_loop is None else self.root_loop.tab
        section=n_tab*tab+str(self.__class__.__name__)
        if n_events:section+=f' {len(self)} events'
        if include_events:
            for event in self.events.values():
                if isinstance(event,(list,L)):
                    for o in event:
                        section+='\n'+(n_tab*tab)+o.show(n_tab=n_tab+1,**kwargs)
                elif event in [_default_raise,noop] and include_defaults:
                    section+='\n'+((n_tab+1)*tab)+str(event)
                elif event not in [_default_raise,noop]:
                    section+='\n'+(n_tab*tab)+event.show(n_tab=n_tab+1,**kwargs)
        return section

    def run(self):
        try:
            self.events['before_']()
            for o in self.events['before_inner']: o.run()                       # fastrl.skip_traceback
            self.events['on_']()
            for o in self.events['on_inner']: o.run()
            self.events['after_']()
            for o in self.events['after_inner']: o.run()                        # fastrl.skip_traceback
        except Exception as ex:
            try:
                self.events['failed_']()                                        # fastrl.skip_traceback
                raise
            finally:
                for o in self.events['failed_inner']: o.run()                   # fastrl.skip_traceback
        finally:
            self.events['finally_']()
            for o in self.events['finally_inner']: o.run()                      # fastrl.skip_traceback

    @classmethod
    def from_events(cls,events:List[Event],loop=None,parent_event=None):
        previous_event={}
        event_groups=groupby(events,partial(_grab_postfix,previous_event=previous_event))
        return [cls(o,parent_event=parent_event) for o in event_groups.values()]

# Cell
def _is_event(o): return issubclass(o.__class__,Event)
def _last_element(ls): return ls[-1]
def _loop2sections(loop,loops,cbs): return loop.sections(loops=loops,cbs=cbs)
def _loop_with_sections(loop,loops,cbs,parent,parent_event):
    loop.loop=parent
    return loop.from_sections(loops=loops,cbs=cbs,parent_event=parent_event)

class class_or_instancemethod(classmethod):
    "From: https://stackoverflow.com/questions/28237955/same-name-for-classmethod-and-instancemethod"
    def __get__(self, instance, type_):
        descr_get = super().__get__ if instance is None else self.__func__.__get__
        return descr_get(instance, type_)

class Loop(object):
    call_on,loop,loops,cbs,tab,verbose=L(),None,None,None,'  ',False

    @class_or_instancemethod
    def events(cls_or_self,loops=None,cbs=None):
        events=L(inspect.getmembers(cls_or_self)).map(_last_element)\
                                                 .filter(_is_event)\
                                                 .sorted()
        for o in events:
            o.loop=cls_or_self
            for cb in L(cbs): cb.loop=cls_or_self
            o.set_cbs(cbs)

        events=chain.from_iterable([
            (o,L(ifnone(loops,L()).filter(isrelevent,event=o)\
                                .map(_loop_with_sections,
                                     loops=loops,cbs=cbs,
                                     parent=cls_or_self,
                                     parent_event=o)))
            for o in events
        ])
        return events

    @class_or_instancemethod
    def get_sections(cls_or_self,loops=None,cbs=None,parent_event=None):
        cls_or_self.loops=ifnone(cls_or_self.loops,loops)
        cls_or_self.cbs=ifnone(cls_or_self.cbs,cbs)
        events=cls_or_self.events(loops=L(cls_or_self.loops),cbs=L(cls_or_self.cbs))
        sections=Section.from_events(events,cls_or_self,parent_event)
        return sections

    @classmethod
    def from_sections(cls,**kwargs):
        loop=cls()
        loop.sections=loop.get_sections(**kwargs)
        return loop

    def run(self,loops=None,cbs=None):
        try:
            sections=self.get_sections(loops=loops,cbs=cbs)                     # fastrl.skip_traceback
            for section in sections:                                            # fastrl.skip_traceback
                section.run()                                                   # fastrl.skip_traceback
        except Exception as e:
            e._show_loop_errors=self.verbose
            raise

    @property
    def root_loop(self): return self if self.loop is None else self.loop
    def __len__(self):  return len(self.sections)
    def __repr__(self): return str(self.__class__.__name__)

    @delegates(Section.show)
    def show(self,n_tab=0,n_sections=False,include_sections=False,**kwargs):
        tab=self.root_loop.tab
        kwargs=merge(dict(n_sections=n_sections,include_sections=include_sections),kwargs)
        loop=n_tab*tab+str(self.__class__.__name__)
        if n_sections:loop+=f' {len(self)} sections'
        if include_sections:
            for section in self.sections:
                loop+='\n'+(n_tab*tab)
                loop+=section.show(n_tab=n_tab+1,**kwargs)
        return loop

# Cell
class CallbackException(Exception):pass

class Callback(object):
    call_on,loop=None,None

    def show(self,n_tab=0,**kwargs):
        tab=self.loop.root_loop.tab if self.loop is not None else '\t'
        return (tab*n_tab)+str(self)

# Cell
def _skip_traceback(s):
    return in_('# fastrl.skip_traceback',s)

def ipy_handle_exception(self, etype, value, tb, tb_offset):
    ## Do something fancy
    stb = self.InteractiveTB.structured_traceback(etype,value,tb,tb_offset=tb_offset)
    if not getattr(value,'_show_loop_errors',True):
        tmp,idxs=[],L(stb).argwhere(_skip_traceback)
        prev_skipped_idx=idxs[0] if idxs else 0
        for i,s in enumerate(stb):
            if i in idxs and i-1!=prev_skipped_idx:
                tmp.append('Skipped Loop Code due to # fastrl.skip_traceback, please use Loop(...verbose=True) to view loop tracebacks\n')
            if i not in idxs:
                tmp.append(s)
            else:
                prev_skipped_idx=i
        stb=tmp
    ## Do something fancy
    self._showtraceback(type, value, stb)

if IN_IPYTHON:
    get_ipython().set_custom_exc((Exception,),ipy_handle_exception)
