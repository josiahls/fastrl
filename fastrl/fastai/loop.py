# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_fastai.loop.ipynb (unless otherwise specified).

__all__ = ['Node', 'PREFIXES', 'PRE2ORDER']

# Cell
# Python native modules
import os
from copy import deepcopy
from typing import *
import types
import logging
import inspect
# Third party libs
from fastcore.all import *
# Local modules

_logger=logging.getLogger(__name__)

# Cell
PREFIXES=['on_','after_','before_','failed_','finally_']
PRE2ORDER={'on_':2,'after_':3,'before_':1,'failed_':4,
           'finally_':5}

class Node(object):
    def __init__(self,
                 function:Callable, # The function to be called on this node.
                 base_loop=None,
                 # The BASE loop that this node is a part of. This will be
                 # different from the loop it is defined in.
                 loop=None,
                 children:List['Node']=None,
                 parent:'Node'=None,
                 order=0,
                 call_on='',
                 call_on2str:bool=False, # Whether to show the call_on the __repr__ and __str__ functions
                 order2str:bool=False, # Whether to show the order the __repr__ and __str__ functions
                 level2str:bool=False, # Whether to show the level the __repr__ and __str__ functions
                 indent2str:str='' # Amount and characters to indent the __repr__ and __str__ functions
                ):
        store_attr()
        if not self.isvalid(function):
            raise ValueError(f"""{function} cannot be private ('_'), and must have
                                 either {PREFIXES}""")
        self.sig=inspect.signature(function)
        self.name=function.__name__
        self.order=order
        self.user_defined_order=False
        for anno in L(anno_ret(function)):
            if 'order' in anno.__args__:
                self.order+=anno.__args__[-1]
                self.user_defined_order=True

        for pre in PREFIXES:
            if self.name.startswith(pre):
                self.postfix=self.name.replace(pre,'')
                self.prefix=pre
                # If order is 0, then we will define the order based on the prefix
                if self.order==0: self.order=PRE2ORDER[pre]
                break

    def __round__(self): return round(self.order)
    def __lt__(self,o:'Node'): return self.order<o.order

    def __str__(self):
        base=f"{self.function.__name__}"
        if self.call_on!='' and self.call_on2str: base=f"{self.call_on}:"+base
        if self.level2str:                        base=f"level:{self.level} "+base
        if self.order2str:                        base=f"order:{self.order} "+base
        base=self.indent2str*(self.level-1)+base
        return base

    def __repr__(self): return str(self)
    def __hash__(self): return hash(f'{self.call_on} {str(self)}')

    @property
    def level(self):
        return 1 if self.parent is None else (1+self.parent.level)

    @classmethod
    def isvalid(cls,name)->bool:
        if isinstance(name,Callable): name=name.__name__
        return not name.startswith('_') and \
          any(name.startswith(pre) for pre in PREFIXES)

add_docs(Node,"""Nodes are used to generate a static loop. They wrap whatever functions
are defined in that loop.""")