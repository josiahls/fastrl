# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02b_fastai.data.pipes.core.ipynb (unless otherwise specified).

__all__ = ['Callback', 'filter_call_on_cbs', 'filter_exclude_under_cbs', 'add_cbs']

# Cell
# Python native modules
import os
import logging
# Third party libs
from fastcore.all import *
import torchdata.datapipes as dp
from torch.utils.data.graph import traverse
from torchdata.datapipes import functional_datapipe
# Local modules


_logger = logging.getLogger()

# Cell
class Callback():
    "A list of data pipes that have an associated job."
    call_on = L()
    exclude_under = L()
    do_copy = False
    immediate_parents = L()
    root_parent = None
    pipes = L()

    @property
    def name(self):
        "Name of the `Callback`, camel-cased and with '*Callback*' removed"
        return class2attr(self, 'Callback')

    def init_pipes(self):pass

    def set_parents(self,immediate_parent):
        if immediate_parent is not None:
            self.immediate_parents.append(immediate_parent)

# Cell
dp.map.MapDataPipe.callbacks = L()
dp.iter.IterDataPipe.callbacks = L()

@patch
def __repr__(self:dp.map.MapDataPipe):
    if self.repr_hook is not None:
        return self.repr_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

@patch
def __str__(self:dp.map.MapDataPipe):
    if self.str_hook is not None:
        return self.str_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

@patch
def __repr__(self:dp.iter.IterDataPipe):
    if self.repr_hook is not None:
        return self.repr_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

@patch
def __str__(self:dp.iter.IterDataPipe):
    if self.str_hook is not None:
        return self.str_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

# Cell
def filter_call_on_cbs(obj, cbs): return tuple(cb for cb in cbs if obj.__class__ in cb.call_on)

# Cell
def filter_exclude_under_cbs(
    pipe:Union[dp.map.MapDataPipe,dp.iter.IterDataPipe],
    cbs:List[Callback]
):
    cbs = tuple(cb for cb in cbs if pipe.__class__  not in cb.exclude_under)
    for v in traverse(pipe,only_datapipe=True).values(): # We dont want to traverse non-dp objects.
        for k,_ in v.items():
            cbs = filter_exclude_under_cbs(k,cbs)
    return cbs

# Cell
# @patch
def add_cbs(self,cbs):
    pipe = self
    if cbs is None or len(cbs)==0: return pipe
    cbs = filter_call_on_cbs(self,cbs)
    cbs = filter_exclude_under_cbs(self,cbs)
    for cb in cbs:
        for dp in cb.pipes: pipe = dp(pipe)
    return pipe


patch_to(dp.map.MapDataPipe)(add_cbs)
patch_to(dp.iter.IterDataPipe)(add_cbs)

# @patch
# def add_cbs(self:dp.iter.IterDataPipe,cbs):
#     pipe = self
#     if cbs is None or len(cbs)==0: return pipe
#     cbs = filter_call_on_cbs(self,cbs)
#     cbs = filter_exclude_under_cbs(self,cbs)
#     for cb in cbs:
#         for dp in cb.pipes: pipe = dp(pipe)
#     return pipe
