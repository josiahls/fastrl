# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02c_fastai.data.pipes.mux.ipynb (unless otherwise specified).

__all__ = ['MultiplexerMapDataPipe']

# Cell
# Python native modules
import os
from inspect import isfunction,ismethod
from typing import *
# Third party libs
from fastcore.all import *
from fastai.torch_basics import *
# from torch.utils.data.dataloader import DataLoader as OrgDataLoader
import torchdata.datapipes as dp
from torch.utils.data.dataloader_experimental import DataLoader2
from fastai.data.transforms import *
# Local modules
from ...loop import *
from ..load import *

# Cell
dp.functional_datapipe('mux')
class MultiplexerMapDataPipe(dp.map.MapDataPipe):
    def __init__(self, *datapipes):
        self.datapipes = datapipes
        # datapipe import standard is import torchdata as dp. We need to make these
        # private
        for _dp in self.datapipes:
            if not isinstance(_dp,dp.map.MapDataPipe):
                dp_types=[type(o) for o in self.datapipes]
                raise ValueError(f'Passed in datapipes need to be MapDataPipes, got {dp_types}')

        self.length: Optional[int] = None
        self._map = {}

    def _setup_datapipe_indexer(self, datapipe) -> Optional[Iterator[Any]]:
        # self._datapipe_iterator: Optional[Iterator[Any]] = None
        # Instead of _datapipe_iterator we have _datapipe_indexer
        # We need to know how to get the index from the main_datapipe. In order
        # to do this, we check if it is...

        # NOTE: THIS IS NOT A GOOD SOLUTION SINCE THIS CANT RELY ON A STANDARD
        # INTERFACE FOR GETTING INDEXES

        # We cash the indexes because we want to be able to have consistent behavior
        # when calling __getitem__ on a child pipe.
        # What we don't want is the main_datapipe being indexed by `str` but the
        # child pipes indexing by `int`...
        if isinstance(datapipe, dp.map.SequenceWrapper):
            return iter(range(len(datapipe)))
        elif hasattr(datapipe, '_map'):
            return iter(datapipe._map)
        elif hasattr(datapipe, 'index_map'):
            return iter(datapipe.index_map)
        else:
            warnings.warn('data pipe will be indexed by len')
            return iter(range(len(datapipe)))

    def __iter__(self):
        iterators = [self._setup_datapipe_indexer(x) for x in self.datapipes]
        finished: Set[int] = set()
        while len(finished) < len(iterators):
            for i in range(len(iterators)):
                if i not in finished:
                    try:
                        index = next(iterators[i])
                        # print(i,index)
                        value = self.datapipes[i][index]
                        # self._map will track which index is associated with
                        # which datapipe...
                        self._map[index] = i
                        yield value
                    except StopIteration:
                        finished.add(i)

    def __getitem__(self, index) -> T_co:
        if index in self._map:
            # self._map[index] -> the datapipe to getitem at, then pass index to
            # get the value
            return self.datapipes[self._map[index]][index]

        # Remember that iter(self) adds index to self._map. So as we iter,
        # we can check if index has be found in a datapipe, and once found, return
        # that value.
        for value in self:
            if index in self._map: return value

        raise IndexError(f'Unable to find {index} in the datapipes')

    def __len__(self):
        if self.length is not None:
            if self.length == -1:
                raise TypeError("{} instance doesn't have valid length".format(type(self).__name__))
            return self.length
        if all(isinstance(_dp, Sized) for _dp in self.datapipes):
            self.length = sum(len(_dp) for _dp in self.datapipes)
        else:
            self.length = -1
        return len(self)
