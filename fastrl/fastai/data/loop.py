# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02b_fastai.data.loop.ipynb (unless otherwise specified).

__all__ = ['Callback', 'Loop', 'filter_exclude_under_cbs', 'default_constructor']

# Cell
# Python native modules
import os
import logging
# Third party libs
from fastcore.all import *
import torchdata.datapipes as dp
from torch.utils.data.graph import traverse
# Local modules
from .pipes.demux import *
from .pipes.mux import *

_logger = logging.getLogger()

# Cell
class Callback():
    "A list of data pipes that have an associated job."
    call_on = L()
    exclude_under = L()
    do_copy = False
    immediate_parents = L()
    root_parent = None

    def set_parents(self,immediate_parent):
        if immediate_parent is not None:
            self.immediate_parents.append(immediate_parent)

# Cell
class Loop(dp.iter.IterDataPipe):
    "A datapipe with nesting and callback capabilities."
    callbacks = L()

    def set_cbs(self,cbs):
        self.callbacks = [cb() if isinstance(cb, type) else cb for cb in cbs]
        for cb in self.callbacks: cb.set_parents(self)

    def filter_call_on_cbs(self, cbs):
        return tuple(cb for cb in cbs if self.__class__ in cb.call_on)

    def __repr__(self): return f'{self.__class__} {self.callbacks}'

    def handle_exeption(self,ex): raise

    def __iter__(self):
        try:
            for cb in self.callbacks:
                getattr(cb,'before_'+self.__class__.__name__.lower(),noop)()
            for record in self.__subiter__():

                for cb in self.callbacks:
                    getattr(cb,'on_'+self.__class__.__name__.lower(),noop)()
                yield record

            for cb in self.callbacks:
                getattr(cb,'after_'+self.__class__.__name__.lower(),noop)()
        except Exception as e:
            for cb in self.callbacks:
                getattr(cb,'failed_'+self.__class__.__name__.lower(),noop)()
            self.handle_exeption(e)
        finally:
            for cb in self.callbacks:
                getattr(cb,'finally_'+self.__class__.__name__.lower(),noop)()

# Cell
def filter_exclude_under_cbs(
    pipe:Union[Loop,dp.iter.IterDataPipe],
    cbs:List[Callback]
):
    cbs = tuple(cb for cb in cbs if pipe.__class__  not in cb.exclude_under)
    for v in traverse(pipe).values():
        for k,_ in v.items():
            cbs = filter_exclude_under_cbs(k,cbs)
    return cbs

# Cell
def default_constructor(
    datapipe:Union[Loop,Dict],
    cbs:List[Callback],
    _outer=True
):
    if _outer and issubclass(datapipe.__class__,Loop):
        for cb in cbs: cb.root_parent=datapipe
    d = datapipe if isinstance(datapipe,dict) else traverse(datapipe)

    for k,v in d.items():
        if issubclass(k.__class__,Loop):
            filtered_cbs = k.filter_call_on_cbs(cbs)
            _logger.info('Given loop: %s, found callbacks: %s',k.__class__,filtered_cbs)
            kept_cbs = filter_exclude_under_cbs(k,filtered_cbs)
            _logger.info('Given loop: %s, filtered callbacks: %s',k.__class__,kept_cbs)
            kept_cbs = [copy(cb) if cb.do_copy else cb for cb in kept_cbs]
            k.set_cbs(kept_cbs)
        if not v: continue
        default_constructor(v, cbs, _outer=False)
