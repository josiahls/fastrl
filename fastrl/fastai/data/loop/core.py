# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02b_fastai.data.loop.core.ipynb (unless otherwise specified).

__all__ = ['Callback', 'filter_call_on_cbs', 'set_cbs', 'filter_exclude_under_cbs', 'soft_compose', 'callback_iter',
           'callback_getitem', 'default_constructor']

# Cell
# Python native modules
import os
import logging
# Third party libs
from fastcore.all import *
import torchdata.datapipes as dp
from torch.utils.data.graph import traverse
from torchdata.datapipes import functional_datapipe
# Local modules


_logger = logging.getLogger()

# Cell
class Callback():
    "A list of data pipes that have an associated job."
    call_on = L()
    exclude_under = L()
    do_copy = False
    immediate_parents = L()
    root_parent = None

    def set_parents(self,immediate_parent):
        if immediate_parent is not None:
            self.immediate_parents.append(immediate_parent)

# Cell
dp.map.MapDataPipe.callbacks = L()
dp.iter.IterDataPipe.callbacks = L()

@patch
def __repr__(self:dp.map.MapDataPipe):
    if self.repr_hook is not None:
        return self.repr_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

@patch
def __str__(self:dp.map.MapDataPipe):
    if self.str_hook is not None:
        return self.str_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

@patch
def __repr__(self:dp.iter.IterDataPipe):
    if self.repr_hook is not None:
        return self.repr_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

@patch
def __str__(self:dp.iter.IterDataPipe):
    if self.str_hook is not None:
        return self.str_hook(self)
    # Instead of showing <torch. ... .MapperMapDataPipe object at 0x.....>, return the class name
    str_rep = str(self.__class__.__qualname__)
    if self.callbacks: return str_rep + str(self.callbacks)
    return str_rep

# Cell
def filter_call_on_cbs(loop, cbs):
    return tuple(cb for cb in cbs if loop.__class__ in cb.call_on)


# Cell
def set_cbs(loop,cbs):
    name = loop.__class__.__name__.lower()
    loop.callbacks = [cb() if isinstance(cb, type) else cb for cb in cbs]
    for cb in loop.callbacks: cb.set_parents(loop)
    for s in ['before','on','after','failed','finally']:
        setattr(loop,f'cb_{s}', L(getattr(cb,f'{s}_{name}') for cb in loop.callbacks if hasattr(cb,f'{s}_{name}')))

# Cell
def filter_exclude_under_cbs(
    pipe:Union[dp.map.MapDataPipe,dp.iter.IterDataPipe],
    cbs:List[Callback]
):
    cbs = tuple(cb for cb in cbs if pipe.__class__  not in cb.exclude_under)
    for v in traverse(pipe).values():
        for k,_ in v.items():
            cbs = filter_exclude_under_cbs(k,cbs)
    return cbs

# Cell
from functools import wraps

def soft_compose(loop,attr): return compose(*getattr(loop,attr,L()))

def callback_iter(f):
    @wraps(f)
    def _inner(self):
        try:
            soft_compose(self,'cb_after')()
            for record in f(self):
                soft_compose(self,'cb_on')()
                yield record
            soft_compose(self,'cb_after')()
        except Exception:
            soft_compose(self,'cb_failed')()
        finally:
            soft_compose(self,'cb_finally')()
    return _inner

def callback_getitem(f):
    @wraps(f)
    def _inner(self, index):
        try:
            soft_compose(self,'cb_before')()
            soft_compose(self,'cb_on')()
            return f(self, index)
            soft_compose(self,'cb_after')()
        except Exception:
            soft_compose(self,'cb_failed')()
        finally:
            soft_compose(self,'cb_finally')()
    return _inner


# Cell
dp.map.Batcher.__getitem__ = callback_getitem(dp.map.Batcher.__getitem__)
dp.iter.Batcher.__iter__ = callback_iter(dp.iter.Batcher.__iter__)

# Cell
def default_constructor(
    datapipe:Union[dp.map.MapDataPipe,dp.iter.IterDataPipe,Dict],
    cbs:List[Callback],
    _outer=True # Only used to differentiate between recursive calls and initial.
):
    if _outer:
        for cb in cbs: cb.root_parent=datapipe
    d = datapipe if isinstance(datapipe,dict) else traverse(datapipe)

    for k,v in d.items():
        filtered_cbs = filter_call_on_cbs(k,cbs)
        _logger.info('Given loop: %s, found callbacks: %s',k.__class__,filtered_cbs)
        kept_cbs = filter_exclude_under_cbs(k,filtered_cbs)
        _logger.info('Given loop: %s, filtered callbacks: %s',k.__class__,kept_cbs)
        kept_cbs = [copy(cb) if cb.do_copy else cb for cb in kept_cbs]
        set_cbs(k,kept_cbs)
        if not v: continue
        default_constructor(v, cbs, _outer=False)
