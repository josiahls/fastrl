# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['StepTypes', 'add_namedtuple_doc', 'add_dataclass_doc', 'SimpleStep', 'StepTypeRegistry', 'Record', 'default_logging',
           'test_in', 'test_out', 'test_len', 'test_lt']

# %% ../nbs/00_core.ipynb 1
# Python native modules
import typing
import logging
# Third party libs
from fastcore.all import in_notebook,in_,test,test_fail,add_docs,ifnone
import torch
from tensordict import tensorclass
# Local modules

# %% ../nbs/00_core.ipynb 6
def _fmt_fld(name,t:typing.Tuple[str,type],namedtuple):
    default_v = ''
    if name in namedtuple._field_defaults:
        default_v = f' = `{namedtuple._field_defaults[name]}`'
    return ' - **%s**:`%s` '%(name,t)+default_v+getattr(namedtuple,name).__doc__

def add_namedtuple_doc(
    t:typing.NamedTuple, # Primary tuple to get docs from
    doc:str, # Primary doc for the overall tuple, where the docs for individual fields will be concated.
    **fields_docs:dict # Field names with associated docs to be attached in the format: field_a='some documentation'
):
    "Add docs to `t` from `doc` along with individual doc fields `fields_docs`"
    if not hasattr(t,'__base_doc__'): t.__base_doc__ = doc
    for k,v in fields_docs.items(): getattr(t,k).__doc__ = v
    # TODO: can we add optional default fields also?
    flds = []
    for k,v in t.__annotations__.items():
        flds.append(_fmt_fld(k,v,t))
    
    s = 'Parameters:\n\n'+'\n'.join(flds)
    t.__doc__ = doc + '\n\n' + s   

def _fmt_dataflass_fld(name,t:typing.Tuple[str,type],obj):
    default_v = ''
    if name in obj.__dataclass_fields__:
        default_v = f' = `{t.default}`'
    return ' - **%s**:`%s` '%(name,t.type)+default_v+obj.__dataclass_fields__[name].metadata

def add_dataclass_doc(
    t:object, # Primary tuple to get docs from
    doc:str, # Primary doc for the overall tuple, where the docs for individual fields will be concated.
    **fields_docs:dict # Field names with associated docs to be attached in the format: field_a='some documentation'
):
    "Add docs to `t` from `doc` along with individual doc fields `fields_docs`"
    if not hasattr(t,'__base_doc__'): t.__base_doc__ = doc
    for k,v in fields_docs.items(): 
        if k in t.__dataclass_fields__:
            t.__dataclass_fields__[k].metadata = v
    # TODO: can we add optional default fields also?
    flds = []
    for k,v in t.__dataclass_fields__.items():
        flds.append(_fmt_dataflass_fld(k,v,t))
    
    s = 'Parameters:\n\n'+'\n'.join(flds)
    t.__doc__ = doc + '\n\n' + s    

# %% ../nbs/00_core.ipynb 7
@tensorclass
class SimpleStep:
    state:        torch.FloatTensor = None
    action:       torch.FloatTensor = None
    next_state:   torch.FloatTensor = None
    terminated:   torch.BoolTensor  = None
    truncated:    torch.BoolTensor  = None
    reward:       torch.FloatTensor = None
    total_reward: torch.FloatTensor = None
    env_id:       torch.LongTensor  = None
    proc_id:      torch.LongTensor  = None
    step_n:       torch.LongTensor  = None
    episode_n:    torch.LongTensor  = None
    image:        torch.FloatTensor = None
    raw_action:   torch.FloatTensor = None

    def __post_init__(self):
        self.state        = ifnone(self.state,       torch.zeros(self.batch_size).to(torch.float32))
        self.action       = ifnone(self.action,      torch.zeros(self.batch_size).to(torch.float32))
        self.next_state   = ifnone(self.next_state,  torch.zeros(self.batch_size).to(torch.float32))
        self.terminated   = ifnone(self.terminated,  torch.zeros(self.batch_size).to(torch.bool))
        self.truncated    = ifnone(self.truncated,   torch.zeros(self.batch_size).to(torch.bool))
        self.reward       = ifnone(self.reward,      torch.zeros(self.batch_size).to(torch.long))
        self.total_reward = ifnone(self.total_reward,torch.zeros(self.batch_size).to(torch.float32))
        self.env_id       = ifnone(self.env_id,      torch.zeros(self.batch_size).to(torch.long))
        self.proc_id      = ifnone(self.proc_id,     torch.zeros(self.batch_size).to(torch.long))
        self.step_n       = ifnone(self.step_n,      torch.zeros(self.batch_size).to(torch.long))
        self.episode_n    = ifnone(self.episode_n,   torch.zeros(self.batch_size).to(torch.long))
        self.image        = ifnone(self.image,       torch.zeros(self.batch_size).to(torch.float32))
        self.raw_action   = ifnone(self.raw_action,  torch.zeros(self.batch_size).to(torch.float32))


    @classmethod
    def random(cls,batch_size,**flds):
        "Returns `cls` with all fields not defined in `flds` with `batch_size`"
        self = cls(batch_size=batch_size,**flds)
        d = self._tensordict
        for k,v in d.items():
            if k in flds:
                continue
            if isinstance(v,torch.BoolTensor):
                v.random_(0,1)
            else:
                v.random_(0,100)
        return self

add_dataclass_doc(
    SimpleStep,
    'Represents a single step in an environment.',
    state = 'Both the initial state of the environment and the previous state.',
    next_state = 'Both the next state, and the last state in the environment',
    terminated = """Represents an ending condition for an environment such as reaching a goal or 'living long enough' as 
                    described by the MDP.
                    Good reference is: https://github.com/openai/gym/blob/39b8661cb09f19cb8c8d2f59b57417517de89cb0/gym/core.py#L151-L155""",
    truncated = """Represents an ending condition for an environment that can be seen as an out of bounds condition either
                   literally going out of bounds, breaking rules, or exceeding the timelimit allowed by the MDP.
                   Good reference is: https://github.com/openai/gym/blob/39b8661cb09f19cb8c8d2f59b57417517de89cb0/gym/core.py#L151-L155'""",
    reward = 'The single reward for this step.',
    total_reward = 'The total accumulated reward for this episode up to this step.',
    action = 'The action that was taken to transition from `state` to `next_state`',
    env_id = 'The environment this step came from (useful for debugging)',
    proc_id = 'The process this step came from (useful for debugging)',
    step_n = 'The step number in a given episode.',
    episode_n = 'The episode this environment is currently running through.',
    image = """Intended for display and logging only. If the intention is to use images for training an
               agent, then use a env wrapper instead.""",
    raw_action="The immediate raw output of the model before any post processing"
)

# %% ../nbs/00_core.ipynb 15
class StepTypeRegistry(object):
    def __init__(self):
        self._registered_types = set()

    def register(self, step_type):
        self._registered_types.add(step_type)

    def is_registered(self, step_type):
        return step_type in self._registered_types

    @property
    def types(self) -> typing.Tuple: return tuple(self._registered_types)

StepTypes = StepTypeRegistry()
StepTypes.register(SimpleStep)

# %% ../nbs/00_core.ipynb 19
class Record(typing.NamedTuple):
    name:str
    value:typing.Any

# %% ../nbs/00_core.ipynb 20
def default_logging(level=logging.WARNING):
    """
    Returns default logging settings.
    If it detects that the environment is a notebook, it turns off timestamps and filenames.
    Otherwise, it includes them.
    """
    if in_notebook():
        return {
            'level': level,
            'format': '%(levelname)s: %(message)s'
        }
    else:
        return {
            'level': level,
            'format': '%(asctime)s - %(filename)s:%(lineno)d - %(levelname)s: %(message)s'
        }

# %% ../nbs/00_core.ipynb 23
def test_in(a,b):
    "`test` that `a in b`"
    test(a,b,in_, ' in ')

# %% ../nbs/00_core.ipynb 25
def test_out(a,b):
    "`test` that `a is not in b` or `a is outside b`"
    test_fail(test,args=(a,b,in_), msg=f'{a} not in {b}')

# %% ../nbs/00_core.ipynb 27
def _len_check(a,b): 
    return len(a)==(len(b) if not isinstance(b,int) else b)

def test_len(a,b,meta_info=''):
    "`test` that `len(a) == int(b) or len(a) == len(b)`"
    test(a,b,_len_check, f' len == len {meta_info}')

# %% ../nbs/00_core.ipynb 29
def _less_than(a,b): return a < b
def test_lt(a,b):
    "`test` that `a < b`"
    test(a,b,_less_than, ' a < b')
