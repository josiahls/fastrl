# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06a_memory.experience_replay.ipynb (unless otherwise specified).

__all__ = ['ExperienceReplayException', 'ExperienceReplay', 'ExperienceReplayCallback', 'get_steps',
           'plot_replay_stats', 'figures_to_html']

# Cell
# Python native modules
import os
from typing import *
# Third party libs
from fastcore.all import *
from fastai.learner import *
from fastai.torch_basics import *
from fastai.torch_core import *
from fastai.callback.all import *
# Local modules
from ..core import *
from ..callback.core import *
from ..data.block import *

# Cell
class ExperienceReplayException(Exception): pass

class ExperienceReplay(object):
    def __init__(self,
                 bs=16,         # Number of entries to query from memory
                 max_sz=200,    # Maximum number of entries to hold. Will start overwriting after.
                 warmup_sz=100,  # Minimum number of entries needed to continue with a batch
                 memory:Optional[BD]=None
                 ):
        "Stores `BD`s in a rotating list `self.memory`"
        store_attr()
        test_lt(warmup_sz-1,max_sz)
        self.memory=memory
        self.pointer=0

    def __add__(self,other:BD):
        "In-place add `other` to memory, overwriting if len(self.memory)>self.max_sz"
        if isinstance(other,tuple) and len(other)==1: other=other[0]
        elif isinstance(other,tuple):                 raise ExperienceReplayException('records need to be `BD`s or 1 element tuples')
        if isinstance(other,dict): other=BD(other)

        if 'td_error' not in other: other['td_error']=TensorBatch(torch.zeros((other.bs(),1)))

        if self.memory is None:
            if other.bs()>self.max_sz:
                self.memory=other[:self.max_sz]
                self.pointer=0           # Keep the pointer 0 since we have basically replaced the memory
                self+other[self.max_sz:] # Recursively add the rest of the batch
            else:
                self.memory=other
                self.pointer=self.memory.bs() # remember that pointer is not an index but number of elements
        else:
            n_over=(other.bs()+self.pointer)-self.max_sz
            if n_over>0: # e.g.: max_sz 200, pointer 195, other is 5.
                self.memory=self.memory[:self.pointer]+other[:-n_over]
                self.pointer=0
                self+other[other.bs()-n_over:]
            else:
                # If the number of elements is not over
                next_pointer=self.pointer+other.bs()
                self.memory=self.memory[:self.pointer]+other+self.memory[next_pointer:]
                self.pointer=next_pointer
        return self

    def __getitem__(self,i):
        return ExperienceReplay(bs=self.bs,max_sz=self.max_sz,
                                warmup_sz=self.warmup_sz,memory=self.memory[i])

    def __radd__(self,other:BD): raise ExperienceReplayException('You can only do experience_reply+[some other element]')

    def __len__(self): return self.memory.bs() if self.memory is not None else 0

    def sample(self)->BD:
        "Returns a sample of size `self.bs`"
        with torch.no_grad():
            idxs=np.random.randint(0,self.memory.bs(),self.bs).tolist()
            samples=self.memory[idxs].mapv(to_device)

        if self.memory.bs()<self.warmup_sz: raise CancelBatchException
        return samples,idxs

    def update_td(self,td_errors:Tensor,idxs:Tensor):
        test_len(idxs.shape,1)
        test_len(td_errors.shape,2)
        self.memory['td_error'][idxs]=td_errors

# Cell
class ExperienceReplayCallback(Callback):
    @delegates(ExperienceReplay)
    def __init__(self,**kwargs):
        "Stores `BD`s in a rotating list `self.memory`"
        store_attr()
        self.experience_replay=ExperienceReplay(**kwargs)

    def after_pred(self):
        "Adds `learn.xb` to memory, then sets `learn.xb=experience_replay.sample()`"
        xb=BD(self.learn.xb[0]).mapv(to_detach)
        self.experience_replay+xb

        self.learn.xb,idxs=self.experience_replay.sample()

# Cell
from IPython.display import HTML
import plotly.express as px
from plotly.express._core import configure_animation_controls
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from plotly.graph_objects import layout
from math import ceil

# Cell
def get_steps(maxlen=0,atomic=False)->Tuple[List[str],Dict]:
    return [[f"{maxlen}"] if atomic else [f'{k}' for k in range(maxlen)],
             dict(frame=dict(duration=50, redraw=False),
                  transition=layout.Transition(duration=0,easing='linear'),
                  easing='linear',
                  fromcurrent=True,
                  mode='immediate')]

# Cell
def plot_replay_stats(experience_replay,columns='td_error',n_cols=2):
    # Get the number of subplots
    columns=columns.split(',')
    if len(columns)<n_cols:
        fig=make_subplots(rows=1,cols=len(columns),subplot_titles=(columns[0]))
    else:
        fig=make_subplots(rows=ceil(len(columns)/n_cols),cols=n_cols,
                          subplot_titles=columns)
    n_frames=None

    # Add the traces for each col
    ys_groups=[]
    for i,col in enumerate(columns):
        ys=experience_replay.memory[col].numpy().reshape(-1,)
        ys_groups.append(ys)
        if n_frames is None: n_frames=len(ys)
        _col=(i%n_cols)+1
        _row=ceil((i+1)/n_cols)

        fig.add_trace(go.Scatter(mode='lines+markers',y=ys),row=_row,col=_col)
        fig.add_trace(
            go.Scatter(
                x=(0,),
                y=(ys[0],),
                mode="markers",
                marker=dict(color="red", size=10)),
            row=_row,col=_col
        )

    def sctr_groups(ys_groups,k):
        return {'data':[go.Scatter(
                                x=(k,),y=(y[k],),mode="markers",
                                marker=dict(color="red", size=10)
                        ) for y in ys_groups],
                'traces':list(np.arange(len(ys_groups))+1)}

    frames=[go.Frame(name=str(k),
                       **sctr_groups(ys_groups,k)
              ) for k in range(n_frames)]
    fig.update(frames=frames)
    configure_animation_controls({'animation_frame':"frame",'labels':columns},go.Scatter,fig)

    return fig

# Cell
def figures_to_html(figs):
    html="<html><head></head><body>" + "\n"
    for fig in figs: html+=fig.to_html().split('<body>')[1].split('</body>')[0]
    html+="</body></html>" + "\n"
    display(HTML(html))