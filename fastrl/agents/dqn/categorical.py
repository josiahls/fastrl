# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/12m_agents.dqn.categorical.ipynb.

# %% auto 0
__all__ = ['PartialCrossEntropy', 'CategoricalQCalc', 'CategoricalDQNLearner', 'MultiModelRunner', 'CategoricalDQNAgent']

# %% ../nbs/12m_agents.dqn.categorical.ipynb 3
# Python native modules
import os
from collections import deque
# Third party libs
from fastcore.all import *
import torchdata.datapipes as dp
from torch.utils.data.dataloader_experimental import DataLoader2
from torch.utils.data.datapipes._typing import _DataPipeMeta, _IterDataPipeMeta
# Local modules
import torch
from torch.nn import *
import torch.nn.functional as F
from torch.optim import *
from fastai.torch_basics import *
from fastai.torch_core import *

from ...core import *
from ..core import *
from ...pipes.core import *
from ...fastai.data.block import *
from ...memory.experience_replay import *
from ..core import *
from ..discrete import *
from ...loggers.core import *
from ...loggers.jupyter_visualizers import *
from ...learner.core import *
from .basic import *
from .target import *

# %% ../nbs/12m_agents.dqn.categorical.ipynb 39
def PartialCrossEntropy(p,q): return (-p*q).sum(dim=1).mean()

# %% ../nbs/12m_agents.dqn.categorical.ipynb 40
class CategoricalQCalc(dp.iter.IterDataPipe):
    debug=False
    def __init__(self,source_datapipe,discount=0.99,nsteps=1,target_sync=300,
                 device='cpu'):
        self.source_datapipe = source_datapipe
        self.discount = discount
        self.nsteps = nsteps
        self.learner = find_pipe_instance(self,LearnerBase)
        self.learner.target_model=deepcopy(self.learner.model)
        self.target_sync = target_sync
        self.device = device
        self.n_batch = 0
                
    def __iter__(self):
        for batch in self.source_datapipe:
            try:
                batch = batch.device(self.device)
                actions = batch.action.long()
                self.learner.done_mask = batch.terminated.reshape(-1,)
                with torch.no_grad():
                    distribution_m = categorical_update(self.learner.target_model.supports,
                                              self.learner.target_model.z_delta,
                                              self.learner.target_model.q(batch.next_state),
                                              self.learner.target_model.p(batch.next_state),
                                              actions,batch.reward,
                                              self.learner.done_mask,nsteps=self.nsteps,
                                              debug=self.debug)
                if self.debug: print(f'distribution_m: {distribution_m.shape}')
                v=self.learner.model(batch.state)
                self.learner.local_v=v
                self.learner.pred_raw=v[np.arange(v.shape[0]),actions.reshape(-1,),:]
                if self.debug: print(f'v: {v.shape}')
                if self.debug: print(f'pred: {self.learner.pred_raw.shape}')
                self.learner.pred=F.log_softmax(self.learner.pred_raw,dim=1)
                if self.debug: print(f'log softmax: {self.learner.pred.shape}')
                t_q = (distribution_m,)
                self.learner.yb=(distribution_m,)

                self.learner.loss_grad = self.learner.loss_func(self.learner.pred, *t_q)
                
                if self.n_batch%self.target_sync==0:
                    self.learner.target_model.load_state_dict(self.learner.model.state_dict())
                self.n_batch+=1
                
                yield batch
            except RuntimeError as e:
                print(f'Failed on batch: {batch}')
                raise

# %% ../nbs/12m_agents.dqn.categorical.ipynb 41
def CategoricalDQNLearner(
    model,
    dls,
    logger_bases=None,
    loss_func=MSELoss(),
    opt=AdamW,
    lr=0.005,
    bs=128,
    max_sz=10000,
    nsteps=1,
    device='cpu'
) -> LearnerHead:
    learner = LearnerBase(model,dls,loss_func=loss_func,opt=opt(model.parameters(),lr=lr))
    learner = BatchCollector(learner,logger_bases=logger_bases,batch_on_pipe=LearnerBase)
    learner = EpocherCollector(learner,logger_bases=logger_bases)
    for logger_base in logger_bases: learner = logger_base.connect_source_datapipe(learner)
    learner = RollingTerminatedRewardCollector(learner,logger_bases)
    learner = EpisodeCollector(learner,logger_bases)
    learner = ExperienceReplay(learner,bs=bs,max_sz=max_sz,clone_detach=dls[0].num_workers>0)
    learner = StepBatcher(learner)
    learner = CategoricalQCalc(learner,nsteps=nsteps,device=device)
    learner = ModelLearnCalc(learner)
    learner = LossCollector(learner,logger_bases)
    learner = LearnerHead(learner)
    return learner

# %% ../nbs/12m_agents.dqn.categorical.ipynb 42
class MultiModelRunner(dp.iter.IterDataPipe):
    "If a model contains multiple models, then we support selecting a sub model."
    def __init__(self,
                 source_datapipe,
                 device:Optional[str]=None,
                 model_name:str='policy'
                ): 
        self.source_datapipe = source_datapipe
        self.agent_base = find_pipe_instance(self.source_datapipe,AgentBase)
        self.model = getattr(self.agent_base.model,model_name)
        self.device = device
    
    def __iter__(self):
        for x in self.source_datapipe:
            if self.device is not None: x = x.to(torch.device(self.device))
            if len(x.shape)==1: x = x.unsqueeze(0)
            yield self.model(x)

# %% ../nbs/12m_agents.dqn.categorical.ipynb 43
def CategoricalDQNAgent(
    model,
    logger_bases=None,
    min_epsilon=0.02,
    max_epsilon=1,
    max_steps=1000,
    device='cpu'
)->AgentHead:
    agent = AgentBase(model)
    agent = StepFieldSelector(agent,field='state')
    agent = MultiModelRunner(agent,device=device)
    agent = ArgMaxer(agent)
    selector = EpsilonSelector(agent,min_epsilon=min_epsilon,max_epsilon=max_epsilon,max_steps=max_steps,device=device)
    if logger_bases is not None: agent = EpsilonCollector(selector,logger_bases)
    agent = ArgMaxer(agent,only_idx=True)
    agent = NumpyConverter(agent)
    agent = PyPrimativeConverter(agent)
    agent = AgentHead(agent)
    return agent
