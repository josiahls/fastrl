# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/01_DataPipes/01f_pipes.iter.firstlast.ipynb.

# %% auto 0
__all__ = ['FirstLastMerger', 'n_first_last_steps_expected']

# %% ../../../nbs/01_DataPipes/01f_pipes.iter.firstlast.ipynb 2
# Python native modules
import warnings
# Third party libs
from fastcore.all import add_docs
import torchdata.datapipes as dp

import torch
# Local modules
from ...core import StepTypes

# %% ../../../nbs/01_DataPipes/01f_pipes.iter.firstlast.ipynb 4
class FirstLastMerger(dp.iter.IterDataPipe):
    def __init__(self, 
                 source_datapipe, 
                 gamma:float=0.99
        ):
        self.source_datapipe = source_datapipe
        self.gamma = gamma
        
    def __iter__(self) -> StepTypes.types:
        self.env_buffer = {}
        for steps in self.source_datapipe:
            if not isinstance(steps,(list,tuple)):
                raise ValueError(f'Expected {self.source_datapipe} to return a list/tuple of steps, however got {type(steps)}')
                
            if len(steps)==1:
                yield steps[0]
                continue
                
            fstep,lstep = steps[0],steps[-1]
            
            reward = fstep.reward
            for step in steps[1:]:
                reward *= self.gamma
                reward += step.reward
                
            yield fstep.__class__(
                state=fstep.state.clone().detach(),
                next_state=lstep.next_state.clone().detach(),
                action=fstep.action,
                terminated=lstep.terminated,
                truncated=lstep.truncated,
                reward=reward,
                total_reward=lstep.total_reward,
                env_id=lstep.env_id,
                proc_id=lstep.proc_id,
                step_n=lstep.step_n,
                episode_n=fstep.episode_n,
                image=fstep.image,
                raw_action=fstep.raw_action
            )
                
add_docs(
    FirstLastMerger,
    """Takes multiple steps and converts them into a single step consisting of properties
    from the first and last steps. Reward is recalculated to factor in the multiple steps.""",
)

# %% ../../../nbs/01_DataPipes/01f_pipes.iter.firstlast.ipynb 13
def n_first_last_steps_expected(
    default_steps:int, # The number of steps the episode would run without n_steps
):
    return default_steps 
    
n_first_last_steps_expected.__doc__=r"""
This function doesnt do much for now. `FirstLastMerger` pretty much undoes the number of steps `nsteps` does.
"""    
