# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/13_metrics.ipynb (unless otherwise specified).

__all__ = ['AvgEpisodeRewardMetric']

# Cell
import torch.nn.utils as nn_utils
from fastai.torch_basics import *
from fastai.data.all import *
from fastai.basics import *
from fastai.metrics import *
from dataclasses import field,asdict
from typing import List,Any,Dict,Callable
from collections import deque
import gym
from torch.optim import *

from .data import *
from .async_data import *
from .basic_agents import *
from .learner import *
from fastai.callback.progress import *
from .ptan_extension import *

import ptan

if IN_NOTEBOOK:
    from IPython import display
    import PIL.Image

# Cell
class AvgEpisodeRewardMetric(Metric):
    def __init__(self,experience_cls:ExperienceFirstLast,always_extend=False):
        self.experience_cls=experience_cls
        self.always_extend=always_extend
        self.rolling_rewards=deque([0],maxlen=100)

    def accumulate(self,learn):
#         yb=learn.yb
#         print(len(yb),len(yb[0]),yb)
        if type(learn.yb[0][0])!=ExperienceFirstLast:
            yb=[]
            for i in range(len(learn.xb[0])):
    #             print(learn.yb)
                yb.append(self.experience_cls(learn.xb[0][i].cpu().detach(),*(learn.yb[j][i].cpu().detach() for j in range(len(learn.yb)))))
        else:
            yb=learn.yb[0]
#             print(yb[-1])
#         yb=[ExperienceFirstLast([0],*(yb[k][i] for k in range(len(yb)))) for i in range(len(yb[0]))]
#         yb=[for yb.items()]
#         print([o.done for o in yb if o.done])
#         print([float(o.episode_reward) for o in yb  if o.done])
        if len([float(o.episode_reward) for o in yb if o.done and int(o.episode_reward)!=0])==0:return
#         print([o.episode_reward for o in yb if o.done])
        if not self.always_extend:
            r=[np.average([float(o.episode_reward) for o in yb if o.done and int(o.episode_reward)!=0])]
        else:
            r=[float(o.episode_reward) for o in yb if o.done and int(o.episode_reward)!=0]
#         print([y for y in yb if y.absolute_end])
#         for r in rewards:
        if len(r)!=0:self.rolling_rewards.extend(r)
#         print(len(rewards))
#         if len(rewards)!=0:self.r=sum(rewards)/len(rewards)

    @property
    def value(self):return np.mean(self.rolling_rewards) if len(self.rolling_rewards)!=1 else self.rolling_rewards[0]
    @property
    def name(self):return 'avg_episode_r'