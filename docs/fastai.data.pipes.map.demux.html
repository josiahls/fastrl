---

title: Basic DataPipes


keywords: fastai
sidebar: home_sidebar

summary: "Basic datapipes for work with fastrl core API."
description: "Basic datapipes for work with fastrl core API."
nb_path: "nbs/02c_fastai.data.pipes.map.demux.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02c_fastai.data.pipes.map.demux.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">fastai.vision.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fastai.vision.data</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fastai.data.external</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">untar_data</span><span class="p">(</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_TINY</span><span class="p">),</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_TINY</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(Path(&#39;/home/fastrl_user/.fastai/data/mnist_tiny&#39;),
 &#39;https://s3.amazonaws.com/fast-ai-sample/mnist_tiny.tgz&#39;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Load the mnist csv...</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">IterableWrapper</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">untar_data</span><span class="p">(</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_TINY</span><span class="p">)</span><span class="o">/</span><span class="s1">&#39;labels.csv&#39;</span><span class="p">)])</span> <span class="c1"># FileOpener really should support Path as well as str</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">FileOpener</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">CSVParser</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">skip_lines</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AddIdx</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>     <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span><span class="n">file</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="o">+=</span><span class="mi">1</span>

<span class="n">base_pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">IterToMapConverter</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">key_value_fn</span><span class="o">=</span><span class="n">AddIdx</span><span class="p">())</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">IterToMapConverter</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">key_value_fn</span><span class="o">=</span><span class="n">AddIdx</span><span class="p">())</span>
<span class="c1"># pipe[5],len(base_pipe)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/opt/conda/lib/python3.7/site-packages/torchdata/datapipes/iter/util/converter.py:97: UserWarning: Data from prior DataPipe are loaded to get length ofIterToMapConverter before execution of the pipeline.Please consider removing len().
  &#34;Data from prior DataPipe are loaded to get length of&#34;
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>1408</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the csv converted into a map, we want to split it into a training and validation dataset...</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">iterator</span><span class="o">=</span><span class="nb">iter</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">})</span>
<span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>1</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DemultiplexerMapDataPipe" class="doc_header"><code>class</code> <code>DemultiplexerMapDataPipe</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/pipes/map/demux.py#L32" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DemultiplexerMapDataPipe</code>(<strong><code>datapipe</code></strong>:<code>MapDataPipe</code>, <strong><code>num_instances</code></strong>:<code>int</code>, <strong><code>classifier_fn</code></strong>:<code>typing.Callable</code>, <strong><code>drop_none</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>source_index</code></strong>:<code>Optional</code>[<code>Iterable</code>[<code>+T_co</code>]]=<em><code>None</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">train_valid_splitter</span><span class="p">(</span><span class="n">o</span><span class="p">):</span> 
    <span class="n">int_mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;train&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;valid&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">int_mapping</span><span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="n">dp1</span><span class="p">,</span> <span class="n">dp2</span> <span class="o">=</span> <span class="n">DemultiplexerMapDataPipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">num_instances</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">classifier_fn</span><span class="o">=</span><span class="n">train_valid_splitter</span><span class="p">,</span> <span class="n">drop_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp1</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">dp2</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span><span class="sa">f</span><span class="s2">&quot;The demux&#39;d dp1 and dp2 when added together should be the same len as pipe </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dp1</span><span class="p">)</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dp2</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dp1</span><span class="p">[</span><span class="mi">60</span><span class="p">],</span><span class="n">dp2</span><span class="p">[</span><span class="mi">60</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>([&#39;train/3/9680.png&#39;, &#39;3&#39;], [&#39;valid/3/9219.png&#39;, &#39;3&#39;])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">dp1</span><span class="p">)[:</span><span class="mi">5</span><span class="p">],</span><span class="nb">list</span><span class="p">(</span><span class="n">dp2</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>([[&#39;train/3/7463.png&#39;, &#39;3&#39;],
  [&#39;train/3/9829.png&#39;, &#39;3&#39;],
  [&#39;train/3/7881.png&#39;, &#39;3&#39;],
  [&#39;train/3/8065.png&#39;, &#39;3&#39;],
  [&#39;train/3/7046.png&#39;, &#39;3&#39;]],
 [[&#39;valid/3/8430.png&#39;, &#39;3&#39;],
  [&#39;valid/3/7946.png&#39;, &#39;3&#39;],
  [&#39;valid/3/933.png&#39;, &#39;3&#39;],
  [&#39;valid/3/9308.png&#39;, &#39;3&#39;],
  [&#39;valid/3/795.png&#39;, &#39;3&#39;]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">KSplitter</span><span class="p">():</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k_splits</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_splits</span><span class="o">=</span><span class="n">k_splits</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="k">finally</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">k_splits</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span>

<span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">,</span><span class="n">k3</span> <span class="o">=</span> <span class="n">DemultiplexerMapDataPipe</span><span class="p">(</span><span class="n">dp1</span><span class="p">,</span><span class="n">num_instances</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">classifier_fn</span><span class="o">=</span><span class="n">KSplitter</span><span class="p">(</span><span class="n">k_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">drop_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">k1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">k2</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">k3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(237, 236, 236)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># import warnings</span>

<span class="c1"># from collections import deque</span>
<span class="c1"># from collections.abc import Hashable</span>

<span class="c1"># from typing import Any, Callable, Iterator, List, Optional, Set, Sized, Tuple, TypeVar, Deque</span>

<span class="c1"># from torch.utils.data import IterDataPipe, functional_datapipe</span>
<span class="c1"># from torch.utils.data.datapipes.utils.common import _check_lambda_fn</span>
<span class="c1"># from torch.utils.data._utils.serialization import serialize_fn, deserialize_fn</span>


<span class="c1"># T_co = TypeVar(&quot;T_co&quot;, covariant=True)</span>



<span class="c1"># class _ChildMapDataPipe(dp.map.MapDataPipe):</span>
<span class="c1">#     def __init__(self, main_datapipe, instance_id: Hashable):</span>
<span class="c1">#         required_attrs = [&quot;get_next_element_by_instance&quot;, &quot;is_instance_started&quot;, &quot;getitem_by_instance&quot;]</span>
<span class="c1">#         required_ops = [getattr(main_datapipe, attr) for attr in required_attrs]</span>
<span class="c1">#         if any(not callable(op) for op in required_ops):</span>
<span class="c1">#             raise NotImplementedError(f&quot;Main Datapipe must have methods {required_attrs} implemented.&quot;)</span>
<span class="c1">#         self.main_datapipe = main_datapipe</span>
<span class="c1">#         self.instance_id = instance_id</span>

<span class="c1">#     def __iter__(self):</span>
<span class="c1">#         # These is no concept of exhaustion of the &#39;main_datapipe&#39;. We only need</span>
<span class="c1">#         # to run through it once, then use the cached indexes for querying.</span>
<span class="c1">#         return self.get_generator_by_instance(self.instance_id)</span>
    
<span class="c1">#     @property</span>
<span class="c1">#     def _map(self): </span>
<span class="c1">#         return self.main_datapipe.child_index_buffers[self.instance_id]</span>

<span class="c1">#     def __len__(self):</span>
<span class="c1">#         if not self.main_datapipe.main_datapipe_exhausted:</span>
<span class="c1">#             warnings.warn(</span>
<span class="c1">#                 &quot;Data from prior DataPipe are loaded to get length of&quot;</span>
<span class="c1">#                 &quot;_ChildMapDataPipe before execution of the pipeline.&quot;</span>
<span class="c1">#                 &quot;Please consider removing len().&quot;</span>
<span class="c1">#             )</span>
<span class="c1">#             return len(list(self.get_generator_by_instance(self.instance_id)))</span>
<span class="c1">#         # Need to be careful here,  the len of `_ChildMapDataPipe` will be &lt;= len(self.main_datapipe)</span>
<span class="c1">#         return len(self.main_datapipe.get_instance_buffer(self.instance_id))</span>

<span class="c1">#     def get_generator_by_instance(self, instance_id: Hashable):</span>
<span class="c1">#         yield from self.main_datapipe.get_next_element_by_instance(self.instance_id)</span>
        
<span class="c1">#     def __getitem__(self, index):</span>
<span class="c1">#         &quot;Gets an item from `self.main_datapipe` in `self.instance_id`&quot;</span>
<span class="c1">#         return self.main_datapipe.getitem_by_instance(self.instance_id, index)</span>


<span class="c1"># class _DemultiplexerMapDataPipe(dp.map.MapDataPipe):</span>
<span class="c1">#     def __init__(self, datapipe: dp.map.MapDataPipe[T_co], </span>
<span class="c1">#                  # num_instances: int,</span>
<span class="c1">#                  instance_keys: Hashable,</span>
<span class="c1">#                  classifier_fn: Callable[[T_co], Optional[int]], drop_none: bool):</span>
<span class="c1">#         self.main_datapipe = datapipe</span>
<span class="c1">#         self._datapipe_indexer: Optional[Iterator[Any]] = None</span>
<span class="c1">#         # self._datapipe_iterator: Optional[Iterator[Any]] = None</span>
<span class="c1">#         self.instance_keys = instance_keys</span>
<span class="c1">#         # The child buffers will store the indexes separated into their respective</span>
<span class="c1">#         # `_ChildMapDataPipe`&#39;s</span>
<span class="c1">#         self.child_index_buffers: Dict[set[T_co]] = {k:set() for k in self.instance_keys}</span>
<span class="c1">#         self.instance_started: Dict[Hashable,bool] = {k:False for k in instance_keys}</span>
<span class="c1">#         self.classifier_fn = classifier_fn</span>
<span class="c1">#         self.drop_none = drop_none</span>
<span class="c1">#         self.main_datapipe_exhausted = False</span>
        
<span class="c1">#     def _setup_datapipe_indexer(self) -&gt; Optional[Iterator[Any]]:</span>
<span class="c1">#         # self._datapipe_iterator: Optional[Iterator[Any]] = None</span>
<span class="c1">#         # Instead of _datapipe_iterator we have _datapipe_indexer</span>
<span class="c1">#         # We need to know how to get the index from the main_datapipe. In order</span>
<span class="c1">#         # to do this, we check if it is...</span>
        
<span class="c1">#         # NOTE: THIS IS NOT A GOOD SOLUTION SINCE THIS CANT RELY ON A STANDARD</span>
<span class="c1">#         # INTERFACE FOR GETTING INDEXES</span>
        
<span class="c1">#         # We cash the indexes because we want to be able to have consistent behavior </span>
<span class="c1">#         # when calling __getitem__ on a child pipe. </span>
<span class="c1">#         # What we don&#39;t want is the main_datapipe being indexed by `str` but the</span>
<span class="c1">#         # child pipes indexing by `int`...</span>
<span class="c1">#         if isinstance(self.main_datapipe, dp.map.SequenceWrapper):</span>
<span class="c1">#             return iter(range(len(self.main_datapipe)))</span>
<span class="c1">#         elif hasattr(self.main_datapipe, &#39;_map&#39;):</span>
<span class="c1">#             return iter(self.main_datapipe._map)</span>
<span class="c1">#         elif hasattr(self.main_datapipe, &#39;index_map&#39;):</span>
<span class="c1">#             return iter(self.main_datapipe.index_map)</span>
<span class="c1">#         else:</span>
<span class="c1">#             warnings.warn(&#39;data pipe will be indexed by len&#39;)</span>
<span class="c1">#             return iter(range(len(self.main_datapipe)))</span>
        
<span class="c1">#     def get_instance_buffer(self, instance_id: Hashable):</span>
<span class="c1">#         return self.child_index_buffers[instance_id]</span>

<span class="c1">#     def _find_next(self, instance_id: Hashable) -&gt; T_co:</span>
<span class="c1">#         while True:</span>
<span class="c1">#             if self.main_datapipe_exhausted:</span>
<span class="c1">#                 raise StopIteration</span>
<span class="c1">#             if self._datapipe_indexer is None:</span>
<span class="c1">#                 raise ValueError(</span>
<span class="c1">#                     &quot;_datapipe_indexer has not been set, likely because this private method is called directly &quot;</span>
<span class="c1">#                     &quot;without invoking get_next_element_by_instance() first.&quot;)</span>
<span class="c1">#             index = next(self._datapipe_indexer)</span>
<span class="c1">#             value = self.main_datapipe[index]</span>
<span class="c1">#             classification = self.classifier_fn(value)</span>
<span class="c1">#             if classification is None and self.drop_none:</span>
<span class="c1">#                 continue</span>
<span class="c1">#             if classification is None or classification not in self.instance_keys:</span>
<span class="c1">#                 raise ValueError(f&quot;Output of the classification fn should be a key in {self.instance_keys}. &quot; +</span>
<span class="c1">#                                  f&quot;{classification} is returned.&quot;)</span>
            
<span class="c1">#             if index not in self.child_index_buffers[classification]:</span>
<span class="c1">#                 self.child_index_buffers[classification].add(index)</span>

<span class="c1">#             if classification == instance_id:</span>
<span class="c1">#                 return value,index</span>
            
<span class="c1">#     def getitem_by_instance(self, instance_id: Hashable, index: Hashable):</span>
<span class="c1">#         # We need to handle the situation where the index is not currently cached.</span>
<span class="c1">#         # In this case we still need to build the cache, while still attempting to </span>
<span class="c1">#         # get the value for `index`</span>
        
<span class="c1">#         # In this case, `main_datapipe_exhausted` which means we still have some</span>
<span class="c1">#         # of the cache to populate possibly.</span>
<span class="c1">#         # Josiah: The main_datapipe_exhausted doesnt make sense in this context.</span>
<span class="c1">#         if index in self.child_index_buffers[instance_id]:</span>
<span class="c1">#             return self.main_datapipe[index]</span>
        
<span class="c1">#         if not self.main_datapipe_exhausted:</span>
<span class="c1">#             for _ in self.get_next_element_by_instance(instance_id):</span>
<span class="c1">#                 if index in self.child_index_buffers[instance_id]:</span>
<span class="c1">#                     return self.main_datapipe[index]</span>
        
<span class="c1">#         raise IndexError(f&#39;Index {index} not found in {instance_id}&#39;)</span>

<span class="c1">#     def get_next_element_by_instance(self, instance_id: Hashable):</span>
<span class="c1">#         # Josiah: The main_datapipe_exhausted doesnt make sense in this context.</span>
<span class="c1">#         if self._datapipe_indexer is None and not self.main_datapipe_exhausted:</span>
<span class="c1">#             self._datapipe_indexer = iter(self._setup_datapipe_indexer())</span>
<span class="c1">#         stop = False</span>
<span class="c1">#         self.instance_started[instance_id] = True</span>
<span class="c1">#         instance_next_indexer = None</span>
        
<span class="c1">#         while not stop:</span>
<span class="c1">#             # We only want to iterate through the indexes once `self._datapipe_indexer` is clear</span>
<span class="c1">#             # so that we are &quot;gaurenteed&quot; to go through all the indexes possible for </span>
<span class="c1">#             # instance_id</span>
<span class="c1">#             if self.child_index_buffers[instance_id] and self.main_datapipe_exhausted:</span>
<span class="c1">#                 instance_next_indexer = self.child_index_buffers[instance_id]</span>
<span class="c1">#                 yield from (self.main_datapipe[index] for index in instance_next_indexer)</span>
<span class="c1">#                 break</span>
<span class="c1">#             else:</span>
<span class="c1">#                 try:</span>
<span class="c1">#                     value,index = self._find_next(instance_id)</span>
<span class="c1">#                     yield value</span>
<span class="c1">#                 except StopIteration:</span>
<span class="c1">#                     stop = True</span>
<span class="c1">#                     self.main_datapipe_exhausted = True</span>
<span class="c1">#                     self._datapipe_indexer = None</span>
                    
<span class="c1">#     def is_instance_started(self, instance_id: Hashable) -&gt; bool:</span>
<span class="c1">#         return self.instance_started[instance_id]</span>

<span class="c1">#     def reset(self):</span>
<span class="c1">#         self._datapipe_indexer: Optional[Iterator[Any]] = None</span>
<span class="c1">#         self.child_index_buffers: Dict[set[T_co]] = {k:set() for k in self.instance_keys}</span>
<span class="c1">#         self.instance_started: Dict[Hashable,bool] = {k:False for k in instance_keys}</span>
<span class="c1">#         self.main_datapipe_exhausted = False</span>

<span class="c1">#     def __getstate__(self):</span>
<span class="c1">#         if IterDataPipe.getstate_hook is not None:</span>
<span class="c1">#             return IterDataPipe.getstate_hook(self)</span>

<span class="c1">#         serialized_fn_with_method = serialize_fn(self.classifier_fn)</span>
<span class="c1">#         state = (</span>
<span class="c1">#             self.main_datapipe,</span>
<span class="c1">#             self.instance_keys,</span>
<span class="c1">#             self.buffer_size,</span>
<span class="c1">#             serialized_fn_with_method,</span>
<span class="c1">#             self.drop_none,</span>
<span class="c1">#         )</span>
<span class="c1">#         return state</span>

<span class="c1">#     def __setstate__(self, state):</span>
<span class="c1">#         (</span>
<span class="c1">#             self.main_datapipe,</span>
<span class="c1">#             self.num_instances,</span>
<span class="c1">#             self.buffer_size,</span>
<span class="c1">#             serialized_fn_with_method,</span>
<span class="c1">#             self.drop_none,</span>
<span class="c1">#         ) = state</span>
<span class="c1">#         self.classifier_fn = deserialize_fn(serialized_fn_with_method)</span>
<span class="c1">#         self._datapipe_indexer: Optional[Iterator[Any]] = None</span>
<span class="c1">#         self.child_index_buffers: Dict[set[T_co]] = {k:set() for k in self.instance_keys}</span>
<span class="c1">#         self.instance_started: Dict[Hashable,bool] = {k:False for k in instance_keys}</span>
<span class="c1">#         self.main_datapipe_exhausted = False</span>

<span class="c1"># class DemultiplexerMapDataPipe(dp.map.MapDataPipe):</span>
<span class="c1">#     def __new__(cls, datapipe: dp.map.MapDataPipe, instance_keys: List[Hashable],</span>
<span class="c1">#                 classifier_fn: Callable[[T_co], Optional[int]], drop_none: bool = False):</span>
<span class="c1">#         if not isinstance(datapipe, dp.map.MapDataPipe):</span>
<span class="c1">#             raise TypeError(f&quot;DemultiplexerMapDataPipe can only apply on MapDataPipe, but found {type(datapipe)}&quot;)</span>
<span class="c1">#         if not instance_keys:</span>
<span class="c1">#             raise ValueError(f&quot;Expected `instance_keys` larger than 0, but {instance_keys} is found&quot;)</span>

<span class="c1">#         _check_lambda_fn(classifier_fn)</span>

<span class="c1">#         container = _DemultiplexerMapDataPipe(datapipe, instance_keys, classifier_fn, drop_none)</span>
<span class="c1">#         return [_ChildMapDataPipe(container, k) for k in instance_keys]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>


