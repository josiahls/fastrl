---

title: Data Block


keywords: fastai
sidebar: home_sidebar

summary: "High level API to quickly get your data in a `DataLoader`s"
description: "High level API to quickly get your data in a `DataLoader`s"
nb_path: "nbs/02e_fastai.data.block.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02e_fastai.data.block.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Transform-Block">Transform Block<a class="anchor-link" href="#Transform-Block"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include note.html content='We will first validate the lower level API on a dqn before making the data block. This is going to be a naive implimentation.' %}</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="TransformBlock" class="doc_header"><code>class</code> <code>TransformBlock</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L40" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>TransformBlock</code>(<strong><code>type_tfms</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>item_tfms</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>batch_tfms</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>cbs</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>dl_type</code></strong>:<code>DataLoader2</code>=<em><code>None</code></em>, <strong><code>dls_kwargs</code></strong>:<code>dict</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>A basic wrapper that links defaults transforms for the data block API</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>type_tfms</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td>One or more <code>Transform</code>s for converting types. These will be re-called if workers!=0 for the dataloader.</td>
</tr>
<tr>
<td><strong><code>item_tfms</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td><code>ItemTransform</code>s, applied on an item</td>
</tr>
<tr>
<td><strong><code>batch_tfms</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td><code>Transform</code>s or <code>RandTransform</code>s, applied by batch</td>
</tr>
<tr>
<td><strong><code>cbs</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td><a href="/fastrl/fastai.data.pipes.core.html#Callback"><code>Callback</code></a>s for use in dataloaders</td>
</tr>
<tr>
<td><strong><code>dl_type</code></strong></td>
<td><code>DataLoader2</code></td>
<td><code>None</code></td>
<td>Task specific <code>TfmdDL</code>, defaults to <code>TfmdDL</code></td>
</tr>
<tr>
<td><strong><code>dls_kwargs</code></strong></td>
<td><code>dict</code></td>
<td><code>None</code></td>
<td>Additional arguments to be passed to <code>DataLoaders</code></td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="simple_iter_loader_loop" class="doc_header"><code>simple_iter_loader_loop</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L57" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>simple_iter_loader_loop</code>(<strong><code>items</code></strong>:<code>Iterable</code>[<code>+T_co</code>], <strong><code>cbs</code></strong>:<code>Optional</code>[<code>List</code>[<a href="/fastrl/fastai.data.pipes.core.html#Callback"><code>Callback</code></a>]]=<em><code>None</code></em>, <strong><code>type_tfms</code></strong>:<code>Optional</code>[<code>Transform</code>]=<em><code>None</code></em>, <strong><code>item_tfms</code></strong>:<code>Optional</code>[<code>Transform</code>]=<em><code>None</code></em>, <strong><code>batch_tfms</code></strong>:<code>Optional</code>[<code>Transform</code>]=<em><code>None</code></em>, <strong><code>bs</code></strong>:<code>int</code>=<em><code>1</code></em>, <strong><code>n</code></strong>:<code>int</code>=<em><code>1</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DataBlock" class="doc_header"><code>class</code> <code>DataBlock</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L79" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DataBlock</code>(<strong><code>blocks</code></strong>:<code>List</code>[<a href="/fastrl/fastai.data.block.html#TransformBlock"><code>TransformBlock</code></a>]=<em><code>None</code></em>, <strong><code>loader_loop</code></strong>:<code>typing.Callable</code>=<em><code>None</code></em>, <strong><code>dl_type</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>blocks</code></strong></td>
<td><code>typing.List[fastrl.fastai.data.block.TransformBlock]</code></td>
<td><code>None</code></td>
<td>Transform blocks to use</td>
</tr>
<tr>
<td><strong><code>loader_loop</code></strong></td>
<td><code>typing.Callable</code></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
<tr>
<td><strong><code>dl_type</code></strong></td>
<td></td>
<td><code>None</code></td>
<td><em>No Content</em></td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Example">Example<a class="anchor-link" href="#Example"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NStepPipe" class="doc_header"><code>class</code> <code>NStepPipe</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L132" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NStepPipe</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NSkipPipe" class="doc_header"><code>class</code> <code>NSkipPipe</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L156" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NSkipPipe</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NStepCallback" class="doc_header"><code>class</code> <code>NStepCallback</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L176" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NStepCallback</code>(<strong><code>nsteps</code></strong>=<em><code>1</code></em>, <strong><code>nskip</code></strong>=<em><code>1</code></em>) :: <a href="/fastrl/fastai.data.pipes.core.html#Callback"><code>Callback</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DictCollate" class="doc_header"><code>class</code> <code>DictCollate</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L187" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DictCollate</code>(<strong><code>self</code></strong>, <strong><code>enc</code></strong>=<em><code>None</code></em>, <strong><code>dec</code></strong>=<em><code>None</code></em>, <strong><code>split_idx</code></strong>=<em><code>None</code></em>, <strong><code>order</code></strong>=<em><code>None</code></em>) :: <code>Transform</code></p>
</blockquote>
<p>Delegates (<code>__call__</code>,<code>decode</code>,<code>setup</code>) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if <code>split_idx</code> matches</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DictToTensor" class="doc_header"><code>class</code> <code>DictToTensor</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L190" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DictToTensor</code>(<strong><code>self</code></strong>, <strong><code>enc</code></strong>=<em><code>None</code></em>, <strong><code>dec</code></strong>=<em><code>None</code></em>, <strong><code>split_idx</code></strong>=<em><code>None</code></em>, <strong><code>order</code></strong>=<em><code>None</code></em>) :: <code>Transform</code></p>
</blockquote>
<p>Delegates (<code>__call__</code>,<code>decode</code>,<code>setup</code>) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if <code>split_idx</code> matches</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="GymTypeTransform" class="doc_header"><code>class</code> <code>GymTypeTransform</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L214" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>GymTypeTransform</code>(<strong><code>self</code></strong>, <strong><code>enc</code></strong>=<em><code>None</code></em>, <strong><code>dec</code></strong>=<em><code>None</code></em>, <strong><code>split_idx</code></strong>=<em><code>None</code></em>, <strong><code>order</code></strong>=<em><code>None</code></em>) :: <code>Transform</code></p>
</blockquote>
<p>Delegates (<code>__call__</code>,<code>decode</code>,<code>setup</code>) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if <code>split_idx</code> matches</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="GymStepTransform" class="doc_header"><code>class</code> <code>GymStepTransform</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L217" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>GymStepTransform</code>(<strong><code>self</code></strong>, <strong><code>agent</code></strong>=<em><code>None</code></em>, <strong><code>enc</code></strong>=<em><code>None</code></em>, <strong><code>dec</code></strong>=<em><code>None</code></em>, <strong><code>split_idx</code></strong>=<em><code>None</code></em>, <strong><code>order</code></strong>=<em><code>None</code></em>) :: <code>Transform</code></p>
</blockquote>
<p>Delegates (<code>__call__</code>,<code>decode</code>,<code>setup</code>) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if <code>split_idx</code> matches</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DQN" class="doc_header"><code>class</code> <code>DQN</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L254" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DQN</code>(<strong><code>state_sz</code></strong>:<code>int</code>, <strong><code>action_sz</code></strong>:<code>int</code>, <strong><code>hidden</code></strong>=<em><code>512</code></em>) :: <code>Module</code></p>
</blockquote>
<p>Same as <code>nn.Module</code>, but no need for subclasses to call <code>super().__init__</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Agent" class="doc_header"><code>class</code> <code>Agent</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L263" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Agent</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RawOutOfStep" class="doc_header"><code>class</code> <code>RawOutOfStep</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L274" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RawOutOfStep</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ArgmaxOfStep" class="doc_header"><code>class</code> <code>ArgmaxOfStep</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L286" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ArgmaxOfStep</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ToDiscrete" class="doc_header"><code>class</code> <code>ToDiscrete</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L295" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ToDiscrete</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DiscreteEpsilonRandomSelect" class="doc_header"><code>class</code> <code>DiscreteEpsilonRandomSelect</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L311" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DiscreteEpsilonRandomSelect</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>IterDataPipe</code></p>
</blockquote>
<p>Iterable-style DataPipe.</p>
<p>All DataPipes that represent an iterable of data samples should subclass this.
This style of DataPipes is particularly useful when data come from a stream, or
when the number of samples is too large to fit them all in memory. <code>IterDataPipe</code> is lazily initialized and its
elements are computed only when <code>next()</code> is called on the iterator of an <code>IterDataPipe</code>.</p>
<p>All subclasses should overwrite :meth:<code>__iter__</code>, which would return an
iterator of samples in this DataPipe. Calling <code>__iter__</code> of an <code>IterDataPipe</code> automatically invokes its
method <code>reset()</code>, which by default performs no operation. When writing a custom <code>IterDataPipe</code>, users should
override <code>reset()</code> if necessary. The common usages include resetting buffers, pointers,
and various state variables within the custom <code>IterDataPipe</code>.</p>
<p>Note:
    Only <code>one</code> iterator can be valid for each <code>IterDataPipe</code> at a time,
    and the creation a second iterator will invalidate the first one. This constraint is necessary because
    some <code>IterDataPipe</code> have internal buffers, whose states can become invalid if there are multiple iterators.
    The code example below presents details on how this constraint looks in practice.
    If you have any feedback related to this constraint, please see <code>GitHub IterDataPipe Single Iterator Issue</code>_.</p>
<p>These DataPipes can be invoked in two ways, using the class constructor or applying their
functional form onto an existing <code>IterDataPipe</code> (recommended, available to most but not all DataPipes).
You can chain multiple <code>IterDataPipe</code> together to form a pipeline that will perform multiple
operations in succession.</p>
<p>.. _GitHub IterDataPipe Single Iterator Issue:
    <a href="https://github.com/pytorch/data/issues/45">https://github.com/pytorch/data/issues/45</a></p>
<p>Note:
    When a subclass is used with :class:<code>~torch.utils.data.DataLoader</code>, each
    item in the DataPipe will be yielded from the :class:<code>~torch.utils.data.DataLoader</code>
    iterator. When :attr:<code>num_workers &gt; 0</code>, each worker process will have a
    different copy of the DataPipe object, so it is often desired to configure
    each copy independently to avoid having duplicate data returned from the
    workers. :func:<code>~torch.utils.data.get_worker_info</code>, when called in a worker
    process, returns information about the worker. It can be used in either the
    dataset's :meth:<code>__iter__</code> method or the :class:<code>~torch.utils.data.DataLoader</code> 's
    :attr:<code>worker_init_fn</code> option to modify each copy's behavior.</p>
<p>Examples:
    General Usage:</p>

<pre><code>    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; map_dp_1 = Mapper(dp, lambda x: x + 1)  # Using class constructor
    &gt;&gt;&gt; map_dp_2 = dp.map(lambda x: x + 1)  # Using functional form (recommended)
    &gt;&gt;&gt; list(map_dp_1)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; list(map_dp_2)
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    &gt;&gt;&gt; filter_dp = map_dp_1.filter(lambda x: x % 2 == 0)
    &gt;&gt;&gt; list(filter_dp)
    [2, 4, 6, 8, 10]
Single Iterator Constraint Example:
    &gt;&gt;&gt; from torchdata.datapipes.iter import IterableWrapper, Mapper
    &gt;&gt;&gt; dp = IterableWrapper(range(10))
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; list(it1)
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    &gt;&gt;&gt; it1 = iter(source_dp)
    &gt;&gt;&gt; it2 = iter(source_dp)  # The creation of a new iterator invalidates `it1`
    &gt;&gt;&gt; next(it2)
    0
    &gt;&gt;&gt; next(it1)  # Further usage of `it1` will raise a `RunTimeError`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span>
                 <span class="n">next_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span>
                 <span class="n">action</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DQN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">agent_base</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span><span class="n">model</span><span class="p">,[</span><span class="n">test_info</span><span class="p">])</span>
<span class="n">agent</span> <span class="o">=</span> <span class="n">RawOutOfStep</span><span class="p">(</span><span class="n">agent_base</span><span class="p">,</span><span class="n">agent_base</span><span class="p">,</span><span class="s1">&#39;state&#39;</span><span class="p">)</span>
<span class="n">agent</span> <span class="o">=</span> <span class="n">DiscreteEpsilonRandomSelect</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span><span class="n">agent_base</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">min_epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">agent</span> <span class="o">=</span> <span class="n">ArgmaxOfStep</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span><span class="n">agent_base</span><span class="p">)</span>
<span class="n">agent</span> <span class="o">=</span> <span class="n">ToDiscrete</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span><span class="n">agent_base</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">action</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">agent</span><span class="p">):</span>
    <span class="n">test_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span>
                 <span class="n">next_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span>
                 <span class="n">action</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
    <span class="n">agent</span><span class="o">.</span><span class="n">agent_base</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_info</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="k">200</span>==0:print(action,agent_base.epislon_selector.epsilon)
    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">7000</span><span class="p">:</span> <span class="k">break</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0 0.9998
1 0.9598
0 0.9198
0 0.8798
0 0.8398
0 0.7998000000000001
1 0.7598
0 0.7198
1 0.6798
0 0.6397999999999999
0 0.5998
1 0.5598000000000001
0 0.5198
0 0.4798
0 0.43979999999999997
0 0.39980000000000004
0 0.3598
0 0.3198
0 0.27980000000000005
0 0.2398
0 0.19979999999999998
0 0.15980000000000005
0 0.11980000000000002
0 0.07979999999999998
0 0.03979999999999995
0 0
0 0
0 0
0 0
0 0
0 0
0 0
0 0
0 0
0 0
0 0
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span>
                 <span class="n">next_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)),</span>
                 <span class="n">action</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="n">agent</span><span class="o">.</span><span class="n">agent_base</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_info</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">GymTransformBlock</span> <span class="o">=</span> <span class="n">TransformBlock</span><span class="p">(</span>
    <span class="n">type_tfms</span>  <span class="o">=</span> <span class="n">GymTypeTransform</span><span class="p">,</span>
    <span class="n">item_tfms</span>  <span class="o">=</span> <span class="p">(</span><span class="n">GymStepTransform</span><span class="p">(</span><span class="n">agent</span><span class="p">),</span><span class="n">DictToTensor</span><span class="p">),</span>
    <span class="n">batch_tfms</span> <span class="o">=</span> <span class="n">DictCollate</span><span class="p">,</span>
    <span class="n">cbs</span> <span class="o">=</span> <span class="n">NStepCallback</span><span class="p">(</span><span class="n">nsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">block</span> <span class="o">=</span> <span class="n">DataBlock</span><span class="p">(</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="n">GymTransformBlock</span><span class="p">,</span>
    <span class="n">loader_loop</span><span class="o">=</span><span class="n">simple_iter_loader_loop</span>
<span class="p">)</span>
<span class="n">pipes</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">datapipes</span><span class="p">([</span><span class="s1">&#39;CartPole-v1&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">bs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dls</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dataloaders</span><span class="p">([</span><span class="s1">&#39;CartPole-v1&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">n_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">dls</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;step_n&#39;</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;done&#39;</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;episode_n&#39;</span><span class="p">])</span>
    
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>TensorBatch([[ 0.0137, -0.0230, -0.0459, -0.0483]]) TensorBatch([[0]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[ 6.4906e-04, -6.0638e-01, -3.2139e-02,  7.8611e-01]]) TensorBatch([[1]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.0115, -0.8010, -0.0164,  1.0685]]) TensorBatch([[2]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.0275, -0.9959,  0.0050,  1.3560]]) TensorBatch([[3]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.0474, -1.1911,  0.0321,  1.6502]]) TensorBatch([[4]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.0712, -1.3866,  0.0651,  1.9527]]) TensorBatch([[5]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.0990, -1.5824,  0.1041,  2.2648]]) TensorBatch([[6]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.1306, -1.7783,  0.1494,  2.5877]]) TensorBatch([[7]]) TensorBatch([[False]]) TensorBatch([[0]])
TensorBatch([[-0.1662, -1.9742,  0.2012,  2.9221]]) TensorBatch([[8]]) TensorBatch([[True]]) TensorBatch([[0]])
TensorBatch([[ 0.0137, -0.0230, -0.0459, -0.0483]]) TensorBatch([[0]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[ 0.0132, -0.2175, -0.0469,  0.2295]]) TensorBatch([[1]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[ 0.0089, -0.4119, -0.0423,  0.5070]]) TensorBatch([[2]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[ 6.4906e-04, -6.0638e-01, -3.2139e-02,  7.8611e-01]]) TensorBatch([[3]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.0115, -0.8010, -0.0164,  1.0685]]) TensorBatch([[4]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.0275, -0.9959,  0.0050,  1.3560]]) TensorBatch([[5]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.0474, -1.1911,  0.0321,  1.6502]]) TensorBatch([[6]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.0712, -1.3866,  0.0651,  1.9527]]) TensorBatch([[7]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.0990, -1.5824,  0.1041,  2.2648]]) TensorBatch([[8]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.1306, -1.7783,  0.1494,  2.5877]]) TensorBatch([[9]]) TensorBatch([[False]]) TensorBatch([[1]])
TensorBatch([[-0.1662, -1.9742,  0.2012,  2.9221]]) TensorBatch([[10]]) TensorBatch([[True]]) TensorBatch([[1]])
TensorBatch([[ 0.0137, -0.0230, -0.0459, -0.0483]]) TensorBatch([[0]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[ 0.0132, -0.2175, -0.0469,  0.2295]]) TensorBatch([[1]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[ 0.0089, -0.4119, -0.0423,  0.5070]]) TensorBatch([[2]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[ 6.4906e-04, -6.0638e-01, -3.2139e-02,  7.8611e-01]]) TensorBatch([[3]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.0115, -0.8010, -0.0164,  1.0685]]) TensorBatch([[4]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.0275, -0.9959,  0.0050,  1.3560]]) TensorBatch([[5]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.0474, -1.1911,  0.0321,  1.6502]]) TensorBatch([[6]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.0712, -1.3866,  0.0651,  1.9527]]) TensorBatch([[7]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.0990, -1.5824,  0.1041,  2.2648]]) TensorBatch([[8]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.1306, -1.7783,  0.1494,  2.5877]]) TensorBatch([[9]]) TensorBatch([[False]]) TensorBatch([[2]])
TensorBatch([[-0.1662, -1.9742,  0.2012,  2.9221]]) TensorBatch([[10]]) TensorBatch([[True]]) TensorBatch([[2]])
TensorBatch([[ 0.0137, -0.0230, -0.0459, -0.0483]]) TensorBatch([[0]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[ 0.0132, -0.2175, -0.0469,  0.2295]]) TensorBatch([[1]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[ 0.0089, -0.4119, -0.0423,  0.5070]]) TensorBatch([[2]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[ 6.4906e-04, -6.0638e-01, -3.2139e-02,  7.8611e-01]]) TensorBatch([[3]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[-0.0115, -0.8010, -0.0164,  1.0685]]) TensorBatch([[4]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[-0.0275, -0.9959,  0.0050,  1.3560]]) TensorBatch([[5]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[-0.0474, -1.1911,  0.0321,  1.6502]]) TensorBatch([[6]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[-0.0712, -1.3866,  0.0651,  1.9527]]) TensorBatch([[7]]) TensorBatch([[False]]) TensorBatch([[3]])
TensorBatch([[-0.0990, -1.5824,  0.1041,  2.2648]]) TensorBatch([[8]]) TensorBatch([[False]]) TensorBatch([[3]])
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">torch.utils.data.graph</span> <span class="kn">import</span> <span class="n">traverse</span>
<span class="kn">from</span> <span class="nn">torchdata.datapipes.utils</span> <span class="kn">import</span> <span class="n">to_graph</span>
<span class="n">to_graph</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_svg output_subarea output_execute_result">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="205pt" height="632pt"
 viewBox="0.00 0.00 205.00 632.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 628)">
<title>%3</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-628 201,-628 201,4 -4,4"/>
<!-- BatchTransformLoop&#45;8773584685441 -->
<g id="node1" class="node">
<title>BatchTransformLoop&#45;8773584685441</title>
<polygon fill="#caff70" stroke="#000000" points="161,-19 36,-19 36,0 161,0 161,-19"/>
<text text-anchor="middle" x="98.5" y="-7" font-family="monospace" font-size="10.00" fill="#000000">BatchTransformLoop</text>
</g>
<!-- InMemoryCacheHolderMapDataPipe&#45;8773584685409 -->
<g id="node2" class="node">
<title>InMemoryCacheHolderMapDataPipe&#45;8773584685409</title>
<polygon fill="#d3d3d3" stroke="#000000" points="197,-514 0,-514 0,-495 197,-495 197,-514"/>
<text text-anchor="middle" x="98.5" y="-502" font-family="monospace" font-size="10.00" fill="#000000">InMemoryCacheHolderMapDataPipe</text>
</g>
<!-- MapToIterConverter&#45;8773584685429 -->
<g id="node3" class="node">
<title>MapToIterConverter&#45;8773584685429</title>
<polygon fill="#d3d3d3" stroke="#000000" points="161,-459 36,-459 36,-440 161,-440 161,-459"/>
<text text-anchor="middle" x="98.5" y="-447" font-family="monospace" font-size="10.00" fill="#000000">MapToIterConverter</text>
</g>
<!-- InMemoryCacheHolderMapDataPipe&#45;8773584685409&#45;&gt;MapToIterConverter&#45;8773584685429 -->
<g id="edge1" class="edge">
<title>InMemoryCacheHolderMapDataPipe&#45;8773584685409&#45;&gt;MapToIterConverter&#45;8773584685429</title>
<path fill="none" stroke="#000000" d="M98.5,-494.9197C98.5,-487.9083 98.5,-478.1442 98.5,-469.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-469.3408 98.5,-459.3408 95.0001,-469.3409 102.0001,-469.3408"/>
</g>
<!-- ShardingFilter&#45;8773584685437 -->
<g id="node11" class="node">
<title>ShardingFilter&#45;8773584685437</title>
<polygon fill="#d3d3d3" stroke="#000000" points="149,-404 48,-404 48,-385 149,-385 149,-404"/>
<text text-anchor="middle" x="98.5" y="-392" font-family="monospace" font-size="10.00" fill="#000000">ShardingFilter</text>
</g>
<!-- MapToIterConverter&#45;8773584685429&#45;&gt;ShardingFilter&#45;8773584685437 -->
<g id="edge9" class="edge">
<title>MapToIterConverter&#45;8773584685429&#45;&gt;ShardingFilter&#45;8773584685437</title>
<path fill="none" stroke="#000000" d="M98.5,-439.9197C98.5,-432.9083 98.5,-423.1442 98.5,-414.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-414.3408 98.5,-404.3408 95.0001,-414.3409 102.0001,-414.3408"/>
</g>
<!-- NStepPipe&#45;8773584684741 -->
<g id="node4" class="node">
<title>NStepPipe&#45;8773584684741</title>
<polygon fill="#d3d3d3" stroke="#000000" points="134,-184 63,-184 63,-165 134,-165 134,-184"/>
<text text-anchor="middle" x="98.5" y="-172" font-family="monospace" font-size="10.00" fill="#000000">NStepPipe</text>
</g>
<!-- Flattener&#45;8773584684681 -->
<g id="node5" class="node">
<title>Flattener&#45;8773584684681</title>
<polygon fill="#d3d3d3" stroke="#000000" points="134,-129 63,-129 63,-110 134,-110 134,-129"/>
<text text-anchor="middle" x="98.5" y="-117" font-family="monospace" font-size="10.00" fill="#000000">Flattener</text>
</g>
<!-- NStepPipe&#45;8773584684741&#45;&gt;Flattener&#45;8773584684681 -->
<g id="edge2" class="edge">
<title>NStepPipe&#45;8773584684741&#45;&gt;Flattener&#45;8773584684681</title>
<path fill="none" stroke="#000000" d="M98.5,-164.9197C98.5,-157.9083 98.5,-148.1442 98.5,-139.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-139.3408 98.5,-129.3408 95.0001,-139.3409 102.0001,-139.3408"/>
</g>
<!-- Batcher&#45;8773584685449 -->
<g id="node7" class="node">
<title>Batcher&#45;8773584685449</title>
<polygon fill="#d3d3d3" stroke="#000000" points="128,-74 69,-74 69,-55 128,-55 128,-74"/>
<text text-anchor="middle" x="98.5" y="-62" font-family="monospace" font-size="10.00" fill="#000000">Batcher</text>
</g>
<!-- Flattener&#45;8773584684681&#45;&gt;Batcher&#45;8773584685449 -->
<g id="edge5" class="edge">
<title>Flattener&#45;8773584684681&#45;&gt;Batcher&#45;8773584685449</title>
<path fill="none" stroke="#000000" d="M98.5,-109.9197C98.5,-102.9083 98.5,-93.1442 98.5,-84.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-84.3408 98.5,-74.3408 95.0001,-84.3409 102.0001,-84.3408"/>
</g>
<!-- TypeTransformLoop&#45;8773584685381 -->
<g id="node6" class="node">
<title>TypeTransformLoop&#45;8773584685381</title>
<polygon fill="#d3d3d3" stroke="#000000" points="158,-569 39,-569 39,-550 158,-550 158,-569"/>
<text text-anchor="middle" x="98.5" y="-557" font-family="monospace" font-size="10.00" fill="#000000">TypeTransformLoop</text>
</g>
<!-- TypeTransformLoop&#45;8773584685381&#45;&gt;InMemoryCacheHolderMapDataPipe&#45;8773584685409 -->
<g id="edge3" class="edge">
<title>TypeTransformLoop&#45;8773584685381&#45;&gt;InMemoryCacheHolderMapDataPipe&#45;8773584685409</title>
<path fill="none" stroke="#000000" d="M98.5,-549.9197C98.5,-542.9083 98.5,-533.1442 98.5,-524.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-524.3408 98.5,-514.3408 95.0001,-524.3409 102.0001,-524.3408"/>
</g>
<!-- Batcher&#45;8773584685449&#45;&gt;BatchTransformLoop&#45;8773584685441 -->
<g id="edge4" class="edge">
<title>Batcher&#45;8773584685449&#45;&gt;BatchTransformLoop&#45;8773584685441</title>
<path fill="none" stroke="#000000" d="M98.5,-54.9197C98.5,-47.9083 98.5,-38.1442 98.5,-29.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-29.3408 98.5,-19.3408 95.0001,-29.3409 102.0001,-29.3408"/>
</g>
<!-- Cycler&#45;8773584685433 -->
<g id="node8" class="node">
<title>Cycler&#45;8773584685433</title>
<polygon fill="#d3d3d3" stroke="#000000" points="125.5,-349 71.5,-349 71.5,-330 125.5,-330 125.5,-349"/>
<text text-anchor="middle" x="98.5" y="-337" font-family="monospace" font-size="10.00" fill="#000000">Cycler</text>
</g>
<!-- ItemTransformLoop&#45;8773584685469 -->
<g id="node9" class="node">
<title>ItemTransformLoop&#45;8773584685469</title>
<polygon fill="#d3d3d3" stroke="#000000" points="158,-294 39,-294 39,-275 158,-275 158,-294"/>
<text text-anchor="middle" x="98.5" y="-282" font-family="monospace" font-size="10.00" fill="#000000">ItemTransformLoop</text>
</g>
<!-- Cycler&#45;8773584685433&#45;&gt;ItemTransformLoop&#45;8773584685469 -->
<g id="edge6" class="edge">
<title>Cycler&#45;8773584685433&#45;&gt;ItemTransformLoop&#45;8773584685469</title>
<path fill="none" stroke="#000000" d="M98.5,-329.9197C98.5,-322.9083 98.5,-313.1442 98.5,-304.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-304.3408 98.5,-294.3408 95.0001,-304.3409 102.0001,-304.3408"/>
</g>
<!-- NSkipPipe&#45;8773584684729 -->
<g id="node12" class="node">
<title>NSkipPipe&#45;8773584684729</title>
<polygon fill="#d3d3d3" stroke="#000000" points="134,-239 63,-239 63,-220 134,-220 134,-239"/>
<text text-anchor="middle" x="98.5" y="-227" font-family="monospace" font-size="10.00" fill="#000000">NSkipPipe</text>
</g>
<!-- ItemTransformLoop&#45;8773584685469&#45;&gt;NSkipPipe&#45;8773584684729 -->
<g id="edge11" class="edge">
<title>ItemTransformLoop&#45;8773584685469&#45;&gt;NSkipPipe&#45;8773584684729</title>
<path fill="none" stroke="#000000" d="M98.5,-274.9197C98.5,-267.9083 98.5,-258.1442 98.5,-249.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-249.3408 98.5,-239.3408 95.0001,-249.3409 102.0001,-249.3408"/>
</g>
<!-- SequenceWrapperMapDataPipe&#45;8773584685389 -->
<g id="node10" class="node">
<title>SequenceWrapperMapDataPipe&#45;8773584685389</title>
<polygon fill="#add8e6" stroke="#000000" points="185,-624 12,-624 12,-605 185,-605 185,-624"/>
<text text-anchor="middle" x="98.5" y="-612" font-family="monospace" font-size="10.00" fill="#000000">SequenceWrapperMapDataPipe</text>
</g>
<!-- SequenceWrapperMapDataPipe&#45;8773584685389&#45;&gt;TypeTransformLoop&#45;8773584685381 -->
<g id="edge7" class="edge">
<title>SequenceWrapperMapDataPipe&#45;8773584685389&#45;&gt;TypeTransformLoop&#45;8773584685381</title>
<path fill="none" stroke="#000000" d="M98.5,-604.9197C98.5,-597.9083 98.5,-588.1442 98.5,-579.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-579.3408 98.5,-569.3408 95.0001,-579.3409 102.0001,-579.3408"/>
</g>
<!-- ShardingFilter&#45;8773584685437&#45;&gt;Cycler&#45;8773584685433 -->
<g id="edge8" class="edge">
<title>ShardingFilter&#45;8773584685437&#45;&gt;Cycler&#45;8773584685433</title>
<path fill="none" stroke="#000000" d="M98.5,-384.9197C98.5,-377.9083 98.5,-368.1442 98.5,-359.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-359.3408 98.5,-349.3408 95.0001,-359.3409 102.0001,-359.3408"/>
</g>
<!-- NSkipPipe&#45;8773584684729&#45;&gt;NStepPipe&#45;8773584684741 -->
<g id="edge10" class="edge">
<title>NSkipPipe&#45;8773584684729&#45;&gt;NStepPipe&#45;8773584684741</title>
<path fill="none" stroke="#000000" d="M98.5,-219.9197C98.5,-212.9083 98.5,-203.1442 98.5,-194.4652"/>
<polygon fill="#000000" stroke="#000000" points="102.0001,-194.3408 98.5,-184.3408 95.0001,-194.3409 102.0001,-194.3408"/>
</g>
</g>
</svg>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>


