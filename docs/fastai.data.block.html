---

title: Data Block


keywords: fastai
sidebar: home_sidebar

summary: "High level API to quickly get your data in a `DataLoader`s"
description: "High level API to quickly get your data in a `DataLoader`s"
nb_path: "nbs/02e_fastai.data.block.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02e_fastai.data.block.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Transform-Block">Transform Block<a class="anchor-link" href="#Transform-Block"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>{% include note.html content='We will first validate the lower level API on a dqn before making the data block. This is going to be a naive implimentation.' %}</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="TransformBlock" class="doc_header"><code>class</code> <code>TransformBlock</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L25" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>TransformBlock</code>(<strong><code>pipe_fn</code></strong>:<code>Callable</code>[<code>typing.Any</code>, <code>int</code>, <code>int</code>, <code>_DataPipeMeta</code>]=<em><code>None</code></em>, <strong><code>type_tfms</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>item_tfms</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>batch_tfms</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>cbs</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>pipe_fn_kwargs</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>dl_type</code></strong>:<code>DataLoader2</code>=<em><code>None</code></em>, <strong><code>dls_kwargs</code></strong>:<code>dict</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>A basic wrapper that links defaults transforms for the data block API</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>pipe_fn</code></strong></td>
<td><code>typing.Callable[[typing.Any, int, int], torch.utils.data.datapipes._typing._DataPipeMeta]</code></td>
<td><code>None</code></td>
<td>A function that initializes a datapipeline and returns a datapipe.<br />Minimum must support:<br /><br />    <code>pipe_fn(source, bs, n)</code><br /><br />Where:<br />  - <code>source</code> is the data to be input into the datapipes<br />  - <code>bs</code> is the batch size of the returned data<br />  - <code>n</code> is the number of iterations to make through the datapipes per epoch</td>
</tr>
<tr>
<td><strong><code>type_tfms</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td>One or more <code>Transform</code>s for converting types. These will be re-called if workers!=0 for the dataloader.</td>
</tr>
<tr>
<td><strong><code>item_tfms</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td><code>ItemTransform</code>s, applied per peice of data (not batch)</td>
</tr>
<tr>
<td><strong><code>batch_tfms</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td><code>Transform</code>s applied over a batch of data</td>
</tr>
<tr>
<td><strong><code>cbs</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td><a href="/fastrl/pipes.core.html#Callback"><code>Callback</code></a>s for use in dataloaders. These usually augment a preexisting pipeline in some way</td>
</tr>
<tr>
<td><strong><code>pipe_fn_kwargs</code></strong></td>
<td><code>dict</code></td>
<td><code>None</code></td>
<td>Additional arguments to be passed to <code>pipe_fn</code></td>
</tr>
<tr>
<td><strong><code>dl_type</code></strong></td>
<td><code>DataLoader2</code></td>
<td><code>None</code></td>
<td>Task specific <code>TfmdDL</code>, defaults to <code>TfmdDL</code></td>
</tr>
<tr>
<td><strong><code>dls_kwargs</code></strong></td>
<td><code>dict</code></td>
<td><code>None</code></td>
<td>Additional arguments to be passed to <code>DataLoaders</code></td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I have some thoughts on <a href="/fastrl/fastai.data.block.html#TransformBlock"><code>TransformBlock</code></a>. I'm wondering if it would be so bad to have each <a href="/fastrl/fastai.data.block.html#TransformBlock"><code>TransformBlock</code></a> serve as a guaranteed input and a guaranteed output as opposed to <a href="https://github.com/fastai/fastai/blob/5b6786a3cf4f98b86dcfed8b30738455ede2c640/fastai/data/block.py#L102">https://github.com/fastai/fastai/blob/5b6786a3cf4f98b86dcfed8b30738455ede2c640/fastai/data/block.py#L102</a> where the n_inp could change based on <code>get_x,get_y</code>.</p>
<p>I think the main issue for me is that there isnt always a <code>y</code> in what im doing so the usage of DataBlock can feel awkward. I also find the nesting of functions difficult to debug easily, which is an issue if the idea is that new users will try to plugin their own stuff.</p>
<p>I felt it got more confusing when the blocks are merged together also.</p>
<p>I think that it would be better, that a <a href="/fastrl/fastai.data.block.html#TransformBlock"><code>TransformBlock</code></a> was 1:1 with a dataloader. So if you have 2 transform blocks,
you have 2 dataloaders that do inputs and outputs. In RL I imagine having 2 separate environments running at the same time and 
collecting information from both of them. The required transforms might be different, so having separate <code>TransformBlocks</code> would
simplify things.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DataBlock" class="doc_header"><code>class</code> <code>DataBlock</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/block.py#L56" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DataBlock</code>(<strong><code>blocks</code></strong>:<code>List</code>[<a href="/fastrl/fastai.data.block.html#TransformBlock"><code>TransformBlock</code></a>]=<em><code>None</code></em>)</p>
</blockquote>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>blocks</code></strong></td>
<td><code>typing.List[fastrl.fastai.data.block.TransformBlock]</code></td>
<td><code>None</code></td>
<td>Each transform block will have its own dataloader.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>


