---

title: DataLoader helpers


keywords: fastai
sidebar: home_sidebar

summary: "An implimentation of the torch DataLoader that instead uses Loop as a base. It"
description: "An implimentation of the torch DataLoader that instead uses Loop as a base. It"
nb_path: "nbs/02b_fastai.data.load.alt.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02b_fastai.data.load.alt.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">bs</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">letters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DataLoader" class="doc_header"><code>class</code> <code>DataLoader</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/load.py#L22" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DataLoader</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <a href="/fastrl/fastai.data.load.html#DataLoader"><code>DataLoader</code></a></p>
</blockquote>
<p>Data loader. Combines a dataset and a sampler, and provides an iterable over
the given dataset.</p>
<p>The :class:<code>~torch.utils.data.DataLoader</code> supports both map-style and
iterable-style datasets with single- or multi-process loading, customizing
loading order and optional automatic batching (collation) and memory pinning.</p>
<p>See :py:mod:<code>torch.utils.data</code> documentation page for more details.</p>
<p>Args:
    dataset (Dataset): dataset from which to load the data.
    batch_size (int, optional): how many samples per batch to load
        (default: <code>1</code>).
    shuffle (bool, optional): set to <code>True</code> to have the data reshuffled
        at every epoch (default: <code>False</code>).
    sampler (Sampler or Iterable, optional): defines the strategy to draw
        samples from the dataset. Can be any <code>Iterable</code> with <code>__len__</code>
        implemented. If specified, :attr:<code>shuffle</code> must not be specified.
    batch_sampler (Sampler or Iterable, optional): like :attr:<code>sampler</code>, but
        returns a batch of indices at a time. Mutually exclusive with
        :attr:<code>batch_size</code>, :attr:<code>shuffle</code>, :attr:<code>sampler</code>,
        and :attr:<code>drop_last</code>.
    num_workers (int, optional): how many subprocesses to use for data
        loading. <code>0</code> means that the data will be loaded in the main process.
        (default: <code>0</code>)
    collate_fn (callable, optional): merges a list of samples to form a
        mini-batch of Tensor(s).  Used when using batched loading from a
        map-style dataset.
    pin_memory (bool, optional): If <code>True</code>, the data loader will copy Tensors
        into CUDA pinned memory before returning them.  If your data elements
        are a custom type, or your :attr:<code>collate_fn</code> returns a batch that is a custom type,
        see the example below.
    drop_last (bool, optional): set to <code>True</code> to drop the last incomplete batch,
        if the dataset size is not divisible by the batch size. If <code>False</code> and
        the size of dataset is not divisible by the batch size, then the last batch
        will be smaller. (default: <code>False</code>)
    timeout (numeric, optional): if positive, the timeout value for collecting a batch
        from workers. Should always be non-negative. (default: <code>0</code>)
    worker_init_fn (callable, optional): If not <code>None</code>, this will be called on each
        worker subprocess with the worker id (an int in <code>[0, num_workers - 1]</code>) as
        input, after seeding and before data loading. (default: <code>None</code>)
    generator (torch.Generator, optional): If not <code>None</code>, this RNG will be used
        by RandomSampler to generate random indexes and multiprocessing to generate
        <code>base_seed</code> for workers. (default: <code>None</code>)
    prefetch_factor (int, optional, keyword-only arg): Number of samples loaded
        in advance by each worker. <code>2</code> means there will be a total of
        2 * num_workers samples prefetched across all workers. (default: <code>2</code>)
    persistent_workers (bool, optional): If <code>True</code>, the data loader will not shutdown
        the worker processes after a dataset has been consumed once. This allows to
        maintain the workers <code>Dataset</code> instances alive. (default: <code>False</code>)</p>
<p>.. warning:: If the <code>spawn</code> start method is used, :attr:<code>worker_init_fn</code>
             cannot be an unpicklable object, e.g., a lambda function. See
             :ref:<code>multiprocessing-best-practices</code> on more details related
             to multiprocessing in PyTorch.</p>
<p>.. warning:: <code>len(dataloader)</code> heuristic is based on the length of the sampler used.
             When :attr:<code>dataset</code> is an :class:<code>~torch.utils.data.IterableDataset</code>,
             it instead returns an estimate based on <code>len(dataset) / batch_size</code>, with proper
             rounding depending on :attr:<code>drop_last</code>, regardless of multi-process loading
             configurations. This represents the best guess PyTorch can make because PyTorch
             trusts user :attr:<code>dataset</code> code in correctly handling multi-process
             loading to avoid duplicate data.</p>

<pre><code>         However, if sharding results in multiple workers having incomplete last batches,
         this estimate can still be inaccurate, because (1) an otherwise complete batch can
         be broken into multiple ones and (2) more than one batch worth of samples can be
         dropped when :attr:`drop_last` is set. Unfortunately, PyTorch can not detect such
         cases in general.

         See `Dataset Types`_ for more details on these two types of datasets and how
         :class:`~torch.utils.data.IterableDataset` interacts with
         `Multi-process data loading`_.

</code></pre>
<p>.. warning:: See :ref:<code>reproducibility</code>, and :ref:<code>dataloader-workers-random-seed</code>, and
             :ref:<code>data-loading-randomness</code> notes for random seed related questions.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><p><strong><code>datapipe</code></strong> : <em><code>&lt;class 'inspect._empty'&gt;</code></em></p>
</li>
<li><p><strong><code>args</code></strong> : <em><code>&lt;class 'inspect._empty'&gt;</code></em></p>
</li>
<li><p><strong><code>bs</code></strong> : <em><code>&lt;class 'int'&gt;</code></em>, <em>optional</em></p>
</li>
<li><p><strong><code>n_workers</code></strong> : <em><code>&lt;class 'int'&gt;</code></em>, <em>optional</em></p>
</li>
<li><p><strong><code>kwargs</code></strong> : <em><code>&lt;class 'inspect._empty'&gt;</code></em></p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BatchLoop" class="doc_header"><code>class</code> <code>BatchLoop</code><a href="https://github.com/josiahls/fastrl/tree/master/fastrl/fastai/data/load.py#L71" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BatchLoop</code>() :: <a href="/fastrl/fastai.loop.html#Loop"><code>Loop</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">letters</span><span class="p">,</span><span class="n">bs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[&#39;a&#39;, &#39;b&#39;]
[&#39;c&#39;, &#39;d&#39;]
[&#39;e&#39;, &#39;f&#39;]
[&#39;g&#39;, &#39;h&#39;]
[&#39;i&#39;, &#39;j&#39;]
[&#39;k&#39;, &#39;l&#39;]
[&#39;m&#39;, &#39;n&#39;]
[&#39;o&#39;, &#39;p&#39;]
[&#39;q&#39;, &#39;r&#39;]
[&#39;s&#39;, &#39;t&#39;]
[&#39;u&#39;, &#39;v&#39;]
[&#39;w&#39;, &#39;x&#39;]
[&#39;y&#39;, &#39;z&#39;]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

