---

title: Basic DataPipes - Multiplexer


keywords: fastai
sidebar: home_sidebar

summary: "Basic datapipes for work with fastrl core API."
description: "Basic datapipes for work with fastrl core API."
nb_path: "nbs/02c_fastai.data.pipes.mux.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02c_fastai.data.pipes.mux.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">fastai.vision.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fastai.vision.data</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fastai.data.external</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">untar_data</span><span class="p">(</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_TINY</span><span class="p">),</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_TINY</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(Path(&#39;/home/fastrl_user/.fastai/data/mnist_tiny&#39;),
 &#39;https://s3.amazonaws.com/fast-ai-sample/mnist_tiny.tgz&#39;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Load the mnist csv...</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">IterableWrapper</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">untar_data</span><span class="p">(</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_TINY</span><span class="p">)</span><span class="o">/</span><span class="s1">&#39;labels.csv&#39;</span><span class="p">)])</span> <span class="c1"># FileOpener really should support Path as well as str</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">FileOpener</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">CSVParser</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">skip_lines</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AddIdx</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>     <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span><span class="n">file</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="o">+=</span><span class="mi">1</span>

<span class="n">base_pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">IterToMapConverter</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">key_value_fn</span><span class="o">=</span><span class="n">AddIdx</span><span class="p">())</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">IterToMapConverter</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">key_value_fn</span><span class="o">=</span><span class="n">AddIdx</span><span class="p">())</span>
<span class="c1"># pipe[5],len(base_pipe)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/home/fastrl_user/src/torchdata/torchdata/datapipes/map/util/utils.py:78: UserWarning: Data from prior DataPipe are loaded to get length ofIterToMapConverter before execution of the pipeline.Please consider removing len().
  &#34;Data from prior DataPipe are loaded to get length of&#34;
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>1408</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the csv converted into a map, we want to split it into a training and validation dataset...</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">fastrl.fastai.data.pipes.demux</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">train_valid_splitter</span><span class="p">(</span><span class="n">o</span><span class="p">):</span> 
    
    <span class="n">int_mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;train&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;valid&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
    
    <span class="k">return</span> <span class="n">int_mapping</span><span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>


<span class="n">dp1</span><span class="p">,</span> <span class="n">dp2</span> <span class="o">=</span> <span class="n">DemultiplexerMapDataPipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span><span class="n">num_instances</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">classifier_fn</span><span class="o">=</span><span class="n">train_valid_splitter</span><span class="p">,</span> <span class="n">drop_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp1</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">dp2</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">pipe</span><span class="p">),</span><span class="sa">f</span><span class="s2">&quot;The demux&#39;d dp1 and dp2 when added together should be the same len as pipe </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dp1</span><span class="p">)</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dp2</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dp1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dp2</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>([&#39;train/3/7463.png&#39;, &#39;3&#39;], [&#39;valid/3/8607.png&#39;, &#39;3&#39;])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">dp1</span><span class="p">)[:</span><span class="mi">5</span><span class="p">],</span><span class="nb">list</span><span class="p">(</span><span class="n">dp2</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>([[&#39;train/3/7463.png&#39;, &#39;3&#39;],
  [&#39;train/3/9829.png&#39;, &#39;3&#39;],
  [&#39;train/3/7881.png&#39;, &#39;3&#39;],
  [&#39;train/3/8065.png&#39;, &#39;3&#39;],
  [&#39;train/3/7046.png&#39;, &#39;3&#39;]],
 [[&#39;valid/3/8430.png&#39;, &#39;3&#39;],
  [&#39;valid/3/7946.png&#39;, &#39;3&#39;],
  [&#39;valid/3/933.png&#39;, &#39;3&#39;],
  [&#39;valid/3/9308.png&#39;, &#39;3&#39;],
  [&#39;valid/3/795.png&#39;, &#39;3&#39;]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">KSplitter</span><span class="p">():</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k_splits</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_splits</span><span class="o">=</span><span class="n">k_splits</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="k">finally</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">k_splits</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span>

<span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">,</span><span class="n">k3</span> <span class="o">=</span> <span class="n">DemultiplexerMapDataPipe</span><span class="p">(</span><span class="n">dp1</span><span class="p">,</span><span class="n">num_instances</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="n">classifier_fn</span><span class="o">=</span><span class="n">KSplitter</span><span class="p">(</span><span class="n">k_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">drop_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">zip_longest</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">torch.utils.data.datapipes._decorator</span> <span class="kn">import</span> <span class="n">functional_datapipe</span>
<span class="kn">from</span> <span class="nn">torch.utils.data.datapipes.datapipe</span> <span class="kn">import</span> <span class="n">MapDataPipe</span>


<span class="nd">@functional_datapipe</span><span class="p">(</span><span class="s2">&quot;mux&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MultiplexerMapDataPipe</span><span class="p">(</span><span class="n">MapDataPipe</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">datapipes</span><span class="p">,</span> <span class="n">dp_index_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">MapDataPipe</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datapipes</span> <span class="o">=</span> <span class="n">datapipes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp_index_map</span> <span class="o">=</span> <span class="n">dp_index_map</span> <span class="k">if</span> <span class="n">dp_index_map</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a generator that yields (index, (dp_num, old_index)) in sequentially order.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_dp_num</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dp</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">datapipes</span><span class="p">))</span>
        <span class="n">dp_id_and_key_tuples</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_gen</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">dp_id_and_key_tuples</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_dp_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dp_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dp</span><span class="p">:</span> <span class="n">MapDataPipe</span><span class="p">):</span>
        <span class="c1"># Assume 0-index for all DataPipes unless alternate indices are defined in `self.dp_index_map`</span>
        <span class="n">dp_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp_index_map</span><span class="p">[</span><span class="n">dp</span><span class="p">]</span> <span class="k">if</span> <span class="n">dp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp_index_map</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">dp_indices</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">dp_num</span><span class="p">,</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                <span class="n">dp_num</span><span class="p">,</span> <span class="n">old_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_key</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">while</span> <span class="n">curr_key</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">:</span>
                    <span class="n">curr_key</span><span class="p">,</span> <span class="n">dp_num_key_tuple</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_gen</span><span class="p">)</span>
                    <span class="n">dp_num</span><span class="p">,</span> <span class="n">old_key</span> <span class="o">=</span> <span class="n">dp_num_key_tuple</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_num</span><span class="p">,</span> <span class="n">old_key</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapipes</span><span class="p">[</span><span class="n">dp_num</span><span class="p">][</span><span class="n">old_key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect key is given to MapDataPipe </span><span class="si">{</span><span class="n">dp_num</span><span class="si">}</span><span class="s2"> in Multiplexer, likely because&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;that DataPipe is not 0-index but alternate indices are not given.&quot;</span>
                <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is out of bound for Multiplexer.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapipes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">SequenceWrapper</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">SequenceWrapper</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">300</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">400</span><span class="p">})</span>
<span class="n">datapipe</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mux</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dp_index_map</span><span class="o">=</span><span class="p">{</span><span class="n">b</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]})</span>
<span class="nb">list</span><span class="p">(</span><span class="n">datapipe</span><span class="p">)</span>  <span class="c1"># Returns [0, 100, 1, 200, 2, 300, 3, 400, 4, 5, 6, 7, 8, 9]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">/tmp/ipykernel_208/4207047274.py</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span>
<span class="ansi-green-fg">----&gt; 1</span><span class="ansi-red-fg"> </span>a <span class="ansi-blue-fg">=</span> SequenceWrapper<span class="ansi-blue-fg">(</span>range<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">10</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      2</span> b <span class="ansi-blue-fg">=</span> SequenceWrapper<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">{</span><span class="ansi-blue-fg">&#39;a&#39;</span><span class="ansi-blue-fg">:</span> <span class="ansi-cyan-fg">100</span><span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#39;b&#39;</span><span class="ansi-blue-fg">:</span> <span class="ansi-cyan-fg">200</span><span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#39;c&#39;</span><span class="ansi-blue-fg">:</span> <span class="ansi-cyan-fg">300</span><span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#39;d&#39;</span><span class="ansi-blue-fg">:</span> <span class="ansi-cyan-fg">400</span><span class="ansi-blue-fg">}</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      3</span> datapipe <span class="ansi-blue-fg">=</span> a<span class="ansi-blue-fg">.</span>mux<span class="ansi-blue-fg">(</span>b<span class="ansi-blue-fg">,</span> dp_index_map<span class="ansi-blue-fg">=</span><span class="ansi-blue-fg">{</span>b<span class="ansi-blue-fg">:</span> <span class="ansi-blue-fg">[</span><span class="ansi-blue-fg">&#39;a&#39;</span><span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#39;b&#39;</span><span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#39;c&#39;</span><span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#39;d&#39;</span><span class="ansi-blue-fg">]</span><span class="ansi-blue-fg">}</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      4</span> list<span class="ansi-blue-fg">(</span>datapipe<span class="ansi-blue-fg">)</span>  <span class="ansi-red-fg"># Returns [0, 100, 1, 200, 2, 300, 3, 400, 4, 5, 6, 7, 8, 9]</span>

<span class="ansi-red-fg">NameError</span>: name &#39;SequenceWrapper&#39; is not defined</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">k1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">k2</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">k3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">combined_pipes</span><span class="o">=</span><span class="n">MultiplexerMapDataPipe</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">,</span><span class="n">k3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">combined_pipes</span><span class="p">)[::</span><span class="mi">100</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">combined_pipes</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">combined_pipes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">combined_pipes</span><span class="p">)[::</span><span class="mi">100</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># dp.functional_datapipe(&#39;mux&#39;)</span>
<span class="c1"># class MultiplexerMapDataPipe(dp.map.MapDataPipe):</span>
<span class="c1">#     def __init__(self, *datapipes):</span>
<span class="c1">#         self.datapipes = datapipes</span>
<span class="c1">#         # datapipe import standard is import torchdata as dp. We need to make these</span>
<span class="c1">#         # private</span>
<span class="c1">#         for _dp in self.datapipes:</span>
<span class="c1">#             if not isinstance(_dp,dp.map.MapDataPipe):</span>
<span class="c1">#                 dp_types=[type(o) for o in self.datapipes]</span>
<span class="c1">#                 raise ValueError(f&#39;Passed in datapipes need to be MapDataPipes, got {dp_types}&#39;)</span>
        
<span class="c1">#         self.length: Optional[int] = None</span>
<span class="c1">#         self._map = {}</span>

<span class="c1">#     def _setup_datapipe_indexer(self, datapipe) -&gt; Optional[Iterator[Any]]:</span>
<span class="c1">#         # self._datapipe_iterator: Optional[Iterator[Any]] = None</span>
<span class="c1">#         # Instead of _datapipe_iterator we have _datapipe_indexer</span>
<span class="c1">#         # We need to know how to get the index from the main_datapipe. In order</span>
<span class="c1">#         # to do this, we check if it is...</span>
        
<span class="c1">#         # NOTE: THIS IS NOT A GOOD SOLUTION SINCE THIS CANT RELY ON A STANDARD</span>
<span class="c1">#         # INTERFACE FOR GETTING INDEXES</span>
        
<span class="c1">#         # We cash the indexes because we want to be able to have consistent behavior </span>
<span class="c1">#         # when calling __getitem__ on a child pipe. </span>
<span class="c1">#         # What we don&#39;t want is the main_datapipe being indexed by `str` but the</span>
<span class="c1">#         # child pipes indexing by `int`...</span>
<span class="c1">#         if isinstance(datapipe, dp.map.SequenceWrapper):</span>
<span class="c1">#             return iter(range(len(datapipe)))</span>
<span class="c1">#         elif hasattr(datapipe, &#39;_map&#39;):</span>
<span class="c1">#             return iter(datapipe._map)</span>
<span class="c1">#         elif hasattr(datapipe, &#39;index_map&#39;):</span>
<span class="c1">#             return iter(datapipe.index_map)</span>
<span class="c1">#         else:</span>
<span class="c1">#             warnings.warn(&#39;data pipe will be indexed by len&#39;)</span>
<span class="c1">#             return iter(range(len(datapipe)))</span>
        
<span class="c1">#     def __iter__(self):</span>
<span class="c1">#         iterators = [self._setup_datapipe_indexer(x) for x in self.datapipes]</span>
<span class="c1">#         finished: Set[int] = set()</span>
<span class="c1">#         while len(finished) &lt; len(iterators):</span>
<span class="c1">#             for i in range(len(iterators)):</span>
<span class="c1">#                 if i not in finished:</span>
<span class="c1">#                     try:</span>
<span class="c1">#                         index = next(iterators[i])</span>
<span class="c1">#                         # print(i,index)</span>
<span class="c1">#                         value = self.datapipes[i][index]</span>
<span class="c1">#                         # self._map will track which index is associated with </span>
<span class="c1">#                         # which datapipe...</span>
<span class="c1">#                         self._map[index] = i</span>
<span class="c1">#                         yield value</span>
<span class="c1">#                     except StopIteration:</span>
<span class="c1">#                         finished.add(i)</span>

<span class="c1">#     def __getitem__(self, index) -&gt; T_co:</span>
<span class="c1">#         if index in self._map:</span>
<span class="c1">#             # self._map[index] -&gt; the datapipe to getitem at, then pass index to </span>
<span class="c1">#             # get the value </span>
<span class="c1">#             return self.datapipes[self._map[index]][index]</span>
        
<span class="c1">#         # Remember that iter(self) adds index to self._map. So as we iter,</span>
<span class="c1">#         # we can check if index has be found in a datapipe, and once found, return </span>
<span class="c1">#         # that value.</span>
<span class="c1">#         for value in self:</span>
<span class="c1">#             if index in self._map: return value</span>
        
<span class="c1">#         raise IndexError(f&#39;Unable to find {index} in the datapipes&#39;)</span>
                        
<span class="c1">#     def __len__(self):</span>
<span class="c1">#         if self.length is not None:</span>
<span class="c1">#             if self.length == -1:</span>
<span class="c1">#                 raise TypeError(&quot;{} instance doesn&#39;t have valid length&quot;.format(type(self).__name__))</span>
<span class="c1">#             return self.length</span>
<span class="c1">#         if all(isinstance(_dp, Sized) for _dp in self.datapipes):</span>
<span class="c1">#             self.length = sum(len(_dp) for _dp in self.datapipes)</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.length = -1</span>
<span class="c1">#         return len(self)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

